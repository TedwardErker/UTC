#+TITLE: Wisconsin Urban Tree Canopy Mapping
#+AUTHOR: Tedward Erker
#+email: erker@wisc.edu
#+PROPERTY:  header-args:R :session *R* :cache no :results output :exports both :tangle yes

* Begin with end in mind
** End Product:
A map of urban cover with associated model uncertainty.  For the
Madison Area.

A reproducible workflow to apply this to any city in WI (or perhaps
country) with minimal work from user.

** Best Classifer
To make this map I need to find the best classifier to apply to the
maps.  To know the best classifier I need to perform an accuracy assessment.


npx = number of pixels in segmentation
cpt = compactness parameter

| Image       | Method | Pixel (Overall Accuracy) | Field Plot (RMSE) | Block (RMSE) |
|-------------+--------+--------------------------+-------------------+--------------|
| NAIP        | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
| PAN_SPOT... |        |                          |                   |              |

** Directory Structure
*** Project Top Directory
**** Pjt_UFIA
- contains this file

**** RD_UrbanAreasShapefile
**** RD_WaterShapefile
**** RD_CroplandDataLayer

**** RD_Training_Regions
***** Madison
Shapefile that contains the regions from which I'll do
manual/supervised classification in the Madison Area
***** Wausau
Shapefile that contains the regions from which I'll do
manual/supervised classification in the Madison Area

**** RD_Accuracy
***** Grids
***** Field Plot
***** Robi's Points
**** RD_NAIP
**** RD_SPOT
**** DD_NAIP
***** Training
****** Madison
******* j directories for each polygon of the training shapefile
******** image : raw image that is cropped to tile
******** masked : image that is masked by water, crops, and urban boundary
******** AddedFeatures : image that has added derived bands
******** PCA : image that is the PCA results scaled to 0 - 255
******** Segmentation : image that is the segmentation layer
******** Segmentation Polygons: polygonized Segmentation Layer
******** SegmentFeatures : dataframe that has each row as segment, columns as features, Class from Segmentation Polygons added.
******** Classified Segmentation Polygons: polygonized Segmentation Layer with manual classifications
******* CombinedSegmentFeatures : dataframe that is combined
****** Wausau
Same as in Madison, but for Wausau

***** Testing
****** grids
******* i directories for each polygon of the grids
******** image : raw image that is cropped to tile
******** masked : image that is masked by water, crops, and urban boundary
******** AddedFeatures : image that has added derived bands
******** PCA : image that is the PCA results scaled to 0 - 255
******** Segmentation : image that is the segmentation layer
******** SegmentFeatures : dataframe that has each row as segment, columns as features.
******** ClassifiedImages : classified images that use each model
********* k classified images for each model

****** fieldplots
Same as for grids

***** Accuracy Assessment
****** Dataframe that summary statistics for each classification, accuracy method
****** Tables of Results


***** Models
R model objects
***** Best Model
R model object, determined by accuracy assessment
***** i directories for each urban area
****** image cropped to urban area .tif
****** j directories for each tile within each of the i urban areas
******* image : raw image that is cropped to tile
******* masked : image that is masked by water, crops, and urban boundary
******* AddedFeatures : image that has added derived bands
******* PCA : image that is the PCA results scaled to 0 - 255
******* Segmentation : image that is the segmentation layer
******* SegmentFeatures : dataframe that has each row as segment, columns as features
******* ClassifiedImage : classified image that uses the best model

**** DD_SPOT
Same structure as DD_NAIP


** Functions I'll need
*** Shapefile
*** ImageTile_to_SegmentationFeaturesDF

#+BEGIN_SRC R
  ImageTile_to_SegmentationFeaturesDF <- function(image,
                                                  water,
                                                  crops,
                                                  urban,

#+END_SRC


Input:
1) Image (4band .tif)
2)



(use foreach and doParallel!)



* Workflow

** Functions
#+BEGIN_SRC R

  Reproject_Shapefile_to_Image_CRS <- function(shapefile.dsn,
                                               shapefile.layer,
                                               image.path,
                                               shapefile.out.path) {
      r <- stack(image)
      shapefile <- readOGR(shapefile.dsn, shapefile.layer)
      shapefile.WimageCRS <- spTransform(shapefile, crs(r))
      writeOGR(shapefile.WimageCRS, shapefile.out.path)

  }





    image_to_segmentationFeatureDFs <- function() I should make this a library of babel chunk since it requires both R and python.  I can specify :var for the inputs.x

    image_to_classified_image <- function()





          # contained urban, don't intersect water = as is
          # contained urban, intersect water = mask water
          # intersect urban, don't intersect water = mask urban
          # intersect urban, intersect water = mask urban & water
        # if none of the above, don't write the raster



        Mask_water_crops_urban <- function(image.full.path, water, crops, urban) {

        }




          Water_Urban_mask <- function(tile.path, tile.name, urban, water) {
                                                  # load image tile
              tile <- stack(tile.path)
                                                  # get extent image and make sp object
              et <- as(extent(tile), "SpatialPolygons")
              proj4string(et) <- "+init=epsg:26916"
                                                  # Mask out non-urban areas
              if(gContainsProperly(urban,et) & !gIntersects(water,et)){
                  writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
              } else if (gContainsProperly(urban,et) & gIntersects(water,et)) {
                  tile <- mask(tile, water, inverse = T)
                  writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
              } else if (gIntersects(urban, et) & !gIntersects(water,et)) {
                  tile <- mask(tile, urban)
                  writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
              } else if (gIntersects(urban, et) & gIntersects(water,et)) {
                  tile <- mask(tile, urban)
                  tile <- mask(tile, water, inverse = T)
                  writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
              }
          }

      Crop_mask <- function(tile.path, tile.name, CDL_stack, n_years){

        tile <- stack(tile.path)
        crops <- crop(CDL_stack, tile)

              # These are the values in the CDL that correspond to non crop cover types and not water
              NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
              # open water is 111

              NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
              # open water is 111. I don't include it in the above list so that it gets masked

              # I'm going to add 37, Other Hay/Non-alfalfa, to the non crop cover types
              NonCroppedValues <- c(NonCroppedValues, 37)
              # I'm going to add 36, Alfalfa, to the non crop cover types
              NonCroppedValues <- c(NonCroppedValues, 36)

              # find cells that have been assigned crop all three years
              crops[crops %in% NonCroppedValues] <- 0
              crops[!(crops %in% NonCroppedValues)] <- 1
              cropsum <- overlay(crops, fun = sum)

              dis.cropsum <- disaggregate(cropsum, fact = 20)
              dis.cropsum <- resample(dis.cropsum, tile, "ngb")
              masked_tile <- mask(tile, dis.cropsum, maskvalue = n_years)

              #               Save Image
              writeRaster(masked_tile, paste0(crop.masked.tiles.directory, "/", tile.name), overwrite = T)
          }








#+END_SRC

** Inputs

Define variables
create directories

#+BEGIN_SRC R

training.region.dsn <- ""
training.region.layer <- ""

#+END_SRC

** NAIP
*** Make SegmentationFeatureDFs for Training Regions
1) Input
   - Testing Region Shapefiles
   - image
2) Operation
   - Reproject Shapefiles to that of image
   - Crop image to each polygon in the shapefile
   - Derive SegmentationFeatureDF from each tile of the image in region of each polygon
3) Output
   - SegmentationFeatureDFs for every training polygon

**** Reproject Training Region Shapefile to Image

#+BEGIN_SRC R

  Reproject_Shapefile_to_Image_CRS(training.region.dsn,
                                   training.region.layer,
                                   image.path,



#+END_SRC

**** Crop image to create a smaller image around each of the testing polygons

**** Create Segmentation Feature Dataframe for each of these smaller images

*** Supervised Classification/ manual classification of segmentation polygons
1) Input
   - Segmentation Layer from the Training Regions
2) Operation
   - Convert Segmentation Layer to Polygons
   - Classify this manually in QGIS and save as Classified Polygons
3) Output
   - Classified segmentation polygons

**** Convert Segmentation Layer to Polygons

**** Manually Classify Polygons

*** Create Models
1) Input
   - SegmentationFeaturesDF
   - Manually/Supervised classified segmentation polygons from
     training regions

2) Operation
   - Merge Training polygons Class with Segmentationfeatures
   - Build Models using mlr
     - untuned
     - tuned

3) Output
   - Models for classifying images
     - RF or SVM (2 options)
       - All 3 classes in one model, or just one class in a model (4 options)
	 - Highly tuned or default parameters (2 options)
   - 2 * 4 * 2 = 16

*** Classify Testing Regions
**** Grids
1) Input
   - Classification Models
   - Testing Region Shapefiles
   - image
2) Operation
   - Reproject Shapefiles to that of image
   - Crop image to each polygon in the shapefile
   - For each possible model Classify each tile of the image in region of each polygon
3) Output
   - classified images for each model for each grid polygon
   - see directory structure, "Testing" header


**** Fieldplot
*** Assess Accuracy
**** Grid
1) Input:
   - classified images for each model for each grid polygon
   - Grid Shapefile

2) Operation
   - For the 4 different grid sizes (50x50, 100x100, 150x150, 200x200)
   - Depending on the Model Target (all three cover types or a single
     cover type), calculate the proportion of cover in the classified image.
   - Calculate Proportion of cover within the grid shapefile
   - Combine shapfile information with classified image information
     and create RMSEs and plots.

3) Output

   - Table of Accuracy by model and grid size
   - RMSE plots
**** Fieldplot

Same as with Grid, but adjust the definitions of "tree" in the field
data and see how accuracy varies.

**** Combine NAIP Accuracy Assessments




** SPOT


** Combine Accuracy Assessment Results


** Classify Every Urban Area in the State











