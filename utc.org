#+TITLE: Wisconsin Urban Tree Canopy Mapping
#+AUTHOR: Tedward Erker
#+email: erker@wisc.edu
#+PROPERTY:  header-args:R :session *R* :cache no :results output :exports both :tangle yes

* Begin with end in mind
** End Product:
A map of urban cover with associated model uncertainty.  For the
Madison Area.

A reproducible workflow to apply this to any city in WI (or perhaps
country) with minimal work from user.

** Best Classifer
To make this map I need to find the best classifier to apply to the
maps.  To know the best classifier I need to perform an accuracy assessment.


npx = number of pixels in segmentation
cpt = compactness parameter

| Image       | Method | Pixel (Overall Accuracy) | Field Plot (RMSE) | Block (RMSE) |
|-------------+--------+--------------------------+-------------------+--------------|
| NAIP        | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             | SVM    |                          |                   |              |
|             | RF     |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
|             |        |                          |                   |              |
| PAN_SPOT... |        |                          |                   |              |

** Directory Structure
*** Project Top Directory
**** Pjt_UFIA
- contains this file

**** RD_UrbanAreasShapefile
**** RD_WaterShapefile
**** RD_CroplandDataLayer

**** RD_Training_Regions
***** Madison
Shapefile that contains the regions from which I'll do
manual/supervised classification in the Madison Area
***** Wausau
Shapefile that contains the regions from which I'll do
manual/supervised classification in the Madison Area

**** RD_Accuracy
***** Grids
***** Field Plot
***** Robi's Points
**** RD_NAIP
**** RD_SPOT
**** DD_NAIP
***** Training
****** Madison
******* j directories for each polygon of the training shapefile
******** image : raw image that is cropped to tile
******** masked : image that is masked by water, crops, and urban boundary
******** AddedFeatures : image that has added derived bands
******** PCA : image that is the PCA results scaled to 0 - 255
******** Segmentation : image that is the segmentation layer
******** Segmentation Polygons: polygonized Segmentation Layer
******** SegmentFeatures : dataframe that has each row as segment, columns as features, Class from Segmentation Polygons added.
******** Classified Segmentation Polygons: polygonized Segmentation Layer with manual classifications
******* CombinedSegmentFeatures : dataframe that is combined
****** Wausau
Same as in Madison, but for Wausau

***** Testing
****** grids
******* i directories for each polygon of the grids
******** image : raw image that is cropped to tile
******** masked : image that is masked by water, crops, and urban boundary
******** AddedFeatures : image that has added derived bands
******** PCA : image that is the PCA results scaled to 0 - 255
******** Segmentation : image that is the segmentation layer
******** SegmentFeatures : dataframe that has each row as segment, columns as features.
******** ClassifiedImages : classified images that use each model
********* k classified images for each model

****** fieldplots
Same as for grids

***** Accuracy Assessment
****** Dataframe that summary statistics for each classification, accuracy method
****** Tables of Results


***** Models
R model objects
***** Best Model
R model object, determined by accuracy assessment
***** i directories for each urban area
****** image cropped to urban area .tif
****** j directories for each tile within each of the i urban areas
******* image : raw image that is cropped to tile
******* masked : image that is masked by water, crops, and urban boundary
******* AddedFeatures : image that has added derived bands
******* PCA : image that is the PCA results scaled to 0 - 255
******* Segmentation : image that is the segmentation layer
******* SegmentFeatures : dataframe that has each row as segment, columns as features
******* ClassifiedImage : classified image that uses the best model

**** DD_SPOT
Same structure as DD_NAIP


* Workflow
** Functions
*** Reproject Shapefile to Image Coordinate Reference System
#+BEGIN_SRC R
    Reproject_Shapefile_to_Image_CRS <- function(shapefile.dsn,
                                                 shapefile.layer,
                                                 image.path,
                                                 shapefile.out.dsn) {
        r <- stack(image.path)
        shapefile <- readOGR(shapefile.dsn, shapefile.layer)
        shapefile.WimageCRS <- spTransform(shapefile, crs(r))
        writeOGR(shapefile.WimageCRS, shapefile.out.dsn, shapefile.layer, driver = "ESRI Shapefile")
    }
#+END_SRC

#+RESULTS:

*** Crop image to each Shapefile polygon
#+BEGIN_SRC R
    Crop_image_to_each_Shapefile_polygon <- function(shapefile.dsn,
                                                     shapefile.layer,
                                                     image.path,
                                                     cores,
                                                     output.dir)  {
        shape <- readOGR(shapefile.dsn, shapefile.layer)
        polygons <- as(shape, "SpatialPolygons")

        image <- stack(image.path)

        cl <- makeCluster(cores)
        registerDoParallel(cl)

        foreach (i = seq_along(polygons),
                 .packages = c("raster")) %dopar% {
                r <- image
                r <- crop(r, polygons[i])
                writeRaster(r, paste0(output.dir,"/",i,".tif"),
                            overwrite = T)
            }
        }

#+END_SRC

#+RESULTS:

*** Crop image to regions around shapefile points
#+BEGIN_SRC R
      Crop_image_to_regions_around_points <- function(shapefile.dsn,
                                                       shapefile.layer,
                                                       image.path,
                                                       cores,
                                                       output.dir)  {

          points <- readOGR(shapefile.dsn, shapefile.layer)
          box <- gBuffer(points, width = 8)
          box <- disaggregate(box)

          polygons <- as(box, "SpatialPolygons")

          image <- stack(image.path)

          cl <- makeCluster(cores)
          registerDoParallel(cl)

          foreach (i = seq_along(polygons),
                   .packages = c("raster")) %dopar% {
                  r <- image
                  r <- crop(r, polygons[i])
                  writeRaster(r, paste0(output.dir,"/",i,".tif"),
                              overwrite = T)
              }
          }

  shapefile.dsn = grid.accuracy.region.imageCRS.dsn
          shapefile.layer = grid.accuracy.region.layer
                                         output.dir = image.cropped.to.grid.accuracy.dir

#+END_SRC

#+RESULTS:
: Error: object 'grid.accuracy.region.imageCRS.dsn' not found
: Error: object 'grid.accuracy.region.layer' not found
: Error: object 'image.cropped.to.grid.accuracy.dir' not found

*** Make new ratio bands from image
#+BEGIN_SRC R
  ratio <- function(image_w4bands, numerator_bandNumber) {
      r <- image_w4bands[,,numerator_bandNumber,drop = F] / sum(image_w4bands)
      return(r)
  }

  ndvi_nodrop <- function(image_w4bands,red_bandnumber,nir_bandnumber,...) {
      red_band <- image_w4bands[[red_bandnumber]]
      nir_band <- image_w4bands[[nir_bandnumber]]
      ndvi <- (nir_band - red_band)/(nir_band + red_band)
      return(ndvi)
  }

  add.ratios.ndvi <- function(tile.dir,
                              tile.name,
                              out.tile.name.append = ratio.tile.name.append,
                              band.names = c("blue","green","red","nir"),
                              red.band.number = 3,
                              nir.band.number = 4) {

      in.tile.path <- str_c(tile.dir, "/", tile.name, ".tif")
      tile <- stack(in.tile.path)
      names(tile) <- band.names

          # Create a ratio image for each band
      ratio.brick <- ratio(tile)
      ratio.brick <- ratio.brick*200 # rescale ndvi to save as 'INT1U'
      names(ratio.brick) <- paste0(band.names,rep("_ratio",times = 4))
      ndvi <- ndvi_nodrop(tile, red.band.number, nir.band.number)
      ndvi <- (ndvi+1)*100 # rescale ndvi to save as 'INT1U'
      ratio.tile <- raster::stack(tile, ratio.brick, ndvi)
      writeRaster(ratio.tile,
                  filename = paste0(tile.dir,"/",tile.name,out.tile.name.append, ".tif"),
                  overwrite = T,
                  datatype = 'INT1U')
      }
#+END_SRC

#+RESULTS:

*** Image PCA
#+BEGIN_SRC R
              getRasterMin <- function(t) {
                  return(min(cellStats(t, stat = "min")))
              }

              getRasterMax <- function(t) {
                  return(max(cellStats(t, stat = "max")))
              }

      rescale.0.255 <- function(raster,
                                min,
                                max) {
                      (raster - min)/(max-min) * 255
                }

      image.pca <- function(image.dir,
                            image.name,
                            in.image.appendage = ratio.tile.name.append,
                            out.image.appendage = pca.tile.name.append,
                            band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
                            comps.to.use = c(1,2,3),
                            pca.model = pca) {


          out.path <- str_c(image.dir, "/", image.name, out.image.appendage, ".tif")

          s <- stack(str_c(image.dir, "/", image.name, in.image.appendage,".tif"))
          names(s) <- band.names

          r <- predict(s, pca.model, index = comps.to.use)

          min.r <- getRasterMin(r)
          max.r <- getRasterMax(r)
          rescaled.r <- rescale.0.255(r, min.r, max.r)
          writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')
      }



  make.and.save.pca.transformation <- function(image.dir,
                                               pca.model.name = "pca.rds",
                                              max.sample.size = 10000,
                                              core.num = cores,
                                              band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")) {
      tile.paths <- list.files(str_c(image.dir), pattern = "*_with_ratios.tif$", full.names = T)
      tile.names <- list.files(str_c(image.dir), pattern = "*_with_ratios.tif$", full.names = F)

      cl <- makeCluster(core.num)
      registerDoParallel(cl)

      sr <- foreach (i = seq_along(tile.names), .packages = c("raster"), .combine ="rbind") %dopar% {
          tile <- stack(tile.paths[i])
          s <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
      }

      colnames(sr) <- band.names

                                              # Perform PCA on sample
      pca <- prcomp(sr, scale = T)
      saveRDS(pca,paste0(image.dir,"/",pca.model.name))
      return(pca)
  }




    ## image.dir <- image.cropped.to.training.dir
    ## image.name <- 9
    ##                         in.image.appendage = ratio.tile.name.append
    ##                         out.image.appendage = pca.tile.name.append
    ##                         band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")
    ##                         max.sample.size = 10000
    ##                         comps.to.use = c(1,2,3)

    ##       out.path <- str_c(image.dir, "/", image.name, out.image.appendage, ".tif")

    ##       s <- stack(str_c(image.dir, "/", image.name, in.image.appendage,".tif"))
    ##       names(s) <- band.names

    ##       sr <- sampleRandom(s, ifelse(ncell(s) > max.sample.size, max.sample.size, ncell(s)))
    ##       pca <- prcomp(sr, scale = T)

    ##       r <- predict(s, pca, index = comps.to.use)

    ##       min.r <- getRasterMin(r)
    ##       max.r <- getRasterMax(r)
    ##       rescaled.r <- rescale.0.255(r, min.r, max.r)
    ##       writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')









              # Function takes raster stack, samples data, performs pca and returns stack of first n_pcomp bands
                ## predict_pca_wSampling_parallel <- function(stack, sampleNumber, n_pcomp, nCores = detectCores()-1) {
                ##     sr <- sampleRandom(stack,sampleNumber)
                ##     pca <- prcomp(sr, scale=T)
                ##     beginCluster()
                ##     r <- clusterR(stack, predict, args = list(pca, index = 1:n_pcomp))
                ##     endCluster()
                ##     return(r)
                ## }
#+END_SRC

#+RESULTS:

*** polygonize segment raster with gdal and add Class to shapefile

#+BEGIN_SRC R
            gdal_polygonizeR <- function(x, outshape=NULL, gdalformat = 'ESRI Shapefile',
                                         pypath=NULL, readpoly=TRUE, quiet=TRUE) {
              if (isTRUE(readpoly)) require(rgdal)
              if (is.null(pypath)) {
                pypath <- Sys.which('gdal_polygonize.py')
              }
              if (!file.exists(pypath)) stop("Can't find gdal_polygonize.py on your system.")
              owd <- getwd()
              on.exit(setwd(owd))
              setwd(dirname(pypath))
              if (!is.null(outshape)) {
                outshape <- sub('\\.shp$', '', outshape)
                f.exists <- file.exists(paste(outshape, c('shp', 'shx', 'dbf'), sep='.'))
                if (any(f.exists))
                  stop(sprintf('File already exists: %s',
                               toString(paste(outshape, c('shp', 'shx', 'dbf'),
                                              sep='.')[f.exists])), call.=FALSE)
              } else outshape <- tempfile()
              if (is(x, 'Raster')) {
                require(raster)
                writeRaster(x, {f <- tempfile(fileext='.asc')})
                rastpath <- normalizePath(f)
              } else if (is.character(x)) {
                rastpath <- normalizePath(x)
              } else stop('x must be a file path (character string), or a Raster object.')
              system2('python', args=(sprintf('"%1$s" "%2$s" -f "%3$s" "%4$s.shp"',
                                              pypath, rastpath, gdalformat, outshape)))
              if (isTRUE(readpoly)) {
                shp <- readOGR(dirname(outshape), layer = basename(outshape), verbose=!quiet)
                return(shp)
              }
              return(NULL)
            }


    polygonize.and.add.Class <- function(image.dir,
                                         image.name,
                                         segment.appendage = segment.tile.name.append,
                                         no.class = "N") {
          seg <- raster(paste0(image.dir,"/",image.name,segment.appendage,'.tif'))
          segPoly <- gdal_polygonizeR(seg)
          segPoly$Class <- no.class
          writeOGR(obj = segPoly,
                   dsn = paste0(image.dir,"/",image.name),
                   layer = paste0(image.name,segment.appendage),
                   driver = "ESRI Shapefile",
                   overwrite = T)
  }






#+END_SRC

#+RESULTS:

*** other Functions
#+BEGIN_SRC R

        image_to_classified_image <- function()





              # contained urban, don't intersect water = as is
              # contained urban, intersect water = mask water
              # intersect urban, don't intersect water = mask urban
              # intersect urban, intersect water = mask urban & water
            # if none of the above, don't write the raster



            Mask_water_crops_urban <- function(image.full.path, water, crops, urban) {

            }




              Water_Urban_mask <- function(tile.path, tile.name, urban, water) {
                                                      # load image tile
                  tile <- stack(tile.path)
                                                      # get extent image and make sp object
                  et <- as(extent(tile), "SpatialPolygons")
                  proj4string(et) <- "+init=epsg:26916"
                                                      # Mask out non-urban areas
                  if(gContainsProperly(urban,et) & !gIntersects(water,et)){
                      writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
                  } else if (gContainsProperly(urban,et) & gIntersects(water,et)) {
                      tile <- mask(tile, water, inverse = T)
                      writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
                  } else if (gIntersects(urban, et) & !gIntersects(water,et)) {
                      tile <- mask(tile, urban)
                      writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
                  } else if (gIntersects(urban, et) & gIntersects(water,et)) {
                      tile <- mask(tile, urban)
                      tile <- mask(tile, water, inverse = T)
                      writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
                  }
              }

          Crop_mask <- function(tile.path, tile.name, CDL_stack, n_years){

            tile <- stack(tile.path)
            crops <- crop(CDL_stack, tile)

                  # These are the values in the CDL that correspond to non crop cover types and not water
                  NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
                  # open water is 111

                  NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
                  # open water is 111. I don't include it in the above list so that it gets masked

                  # I'm going to add 37, Other Hay/Non-alfalfa, to the non crop cover types
                  NonCroppedValues <- c(NonCroppedValues, 37)
                  # I'm going to add 36, Alfalfa, to the non crop cover types
                  NonCroppedValues <- c(NonCroppedValues, 36)

                  # find cells that have been assigned crop all three years
                  crops[crops %in% NonCroppedValues] <- 0
                  crops[!(crops %in% NonCroppedValues)] <- 1
                  cropsum <- overlay(crops, fun = sum)

                  dis.cropsum <- disaggregate(cropsum, fact = 20)
                  dis.cropsum <- resample(dis.cropsum, tile, "ngb")
                  masked_tile <- mask(tile, dis.cropsum, maskvalue = n_years)

                  #               Save Image
                  writeRaster(masked_tile, paste0(crop.masked.tiles.directory, "/", tile.name), overwrite = T)
              }








#+END_SRC

#+RESULTS:

*** Make Segment Feature DF
#+BEGIN_SRC R


    fitXYlm <- function(x,y,z) {
        dat <- data.frame(x,y,z)
        mod <- lm(z ~ x * y, data = dat)
        coefs <-tidy(mod) %>%
            dplyr::select(term,estimate) %>%
            spread(key = term, value = estimate)

        error <- glance(mod) %>%
            select(sigma)

        bind_cols(coefs,error)
    }

    Create.Segment.Feature.df <- function(image.dir,
                                          image.name,
                                          ratio.appendage = ratio.tile.name.append,
                                          segment.appendage = segment.tile.name.append,
                                          segment.feature.df.appendage = segment.feature.df.name.append,
                                          band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")
                                          ){
        ratio.tile.path <- str_c(image.dir, "/", image.name, ratio.tile.name.append, ".tif")
        r.tile <- stack(ratio.tile.path)
        names(r.tile) <- band.names

        seg.tile.path <-  str_c(image.dir, "/", image.name, segment.tile.name.append, ".tif")
        s.tile <- raster(seg.tile.path)

                                            # Create a data_frame where mean and variances are calculated by zone
        x <- as.data.frame(r.tile, xy = T)
        s <- as.data.frame(s.tile)
        colnames(s) <- "segment"
        r <- bind_cols(x,s)
        r2 <- r %>%
            group_by(segment) %>%
            mutate(x.center = x - quantile(x = x, probs = .5),
                   y.center = y - quantile(x = y, probs = .5))

        spatial.model.coef <- r2 %>%
            do(fitXYlm(x = .$x.center, y = .$y.center, z = .$n_ratio))

        mean.and.sd <- r2 %>%
            summarize(mean(blue),
                  mean(green),
                  mean(red),
                  mean(nir),
                  mean(b_ratio),
                  mean(g_ratio),
                  mean(r_ratio),
                  mean(n_ratio),
                  mean(ndvi),
                  sd(blue),
                  sd(green),
                  sd(red),
                  sd(nir),
                  sd(b_ratio),
                  sd(g_ratio),
                  sd(r_ratio),
                  sd(n_ratio),
                  sd(ndvi))

        out <- left_join(spatial.model.coef, mean.and.sd)

        names <- colnames(out)
        names <- str_replace(names, "\\(",".")
        names <- str_replace(names, "\\)",".")
        names <- str_replace(names, "\\:",".")
        colnames(out) <- names

        saveRDS(out, file = paste0(image.dir,"/", image.name, segment.feature.df.appendage,".rds"))
  }
#+END_SRC

#+RESULTS:

*** Create ModelBuilding dataframe by merging segment feature dfs with manually classified segments
#+BEGIN_SRC R
create.df.toBuildModel.fromTrainingPolygons.and.SegmentFeatureDFs <- function(manuallyClassifiedPolygondir,
                                                                              image.dir,
                                                                              segment.feature.df.appendage = segment.feature.df.name.append,
                                                                              modelBuildingData.name = "modelBuildingData.rds") {

    segment.feature.df.appendage = segment.feature.df.name.append

                                        # list shapefiles with manually classified polygons
    trainingShapefiles <- list.files(manuallyClassifiedPolygondir) %>%
        str_sub(.,end = nchar(.)-4) %>%
        unique()

                                        # load training data from shapefiles into memory
    shapelist.data <- lapply(trainingShapefiles, function(shp) {
        readOGR(dsn = manuallyClassifiedPolygondir, layer = shp)@data %>%
                                                                   na.omit() %>%
                                                                   rename(zone = DN) %>%
                                                                   filter(Class != "N")
    })

    names(shapelist.data) <- trainingShapefiles


                                        # list .rds segment feature dataframe files
    segmentFeatureDF.rds.files <- list.files(image.dir, full.names = T) %>%
        str_extract(pattern = str_c(".*",segment.feature.df.appendage,".rds")) %>%
        na.omit()

    trainingData <- list()

    foreach(j = seq_along(shapelist.data)) %do% {
        d <- readRDS(segmentFeatureDF.rds.files[j])
        trainingData[[j]] <- left_join(shapelist.data[[j]],d, by = c("zone" = "segment"))
    }

    trainingData <- bind_rows(trainingData) %>%
        filter(Class != "N")

    saveRDS(trainingData, file = str_c(image.dir, "/",modelBuildingData.name))

}

#+END_SRC
#+RESULTS:

*** Build and Save Models
#+BEGIN_SRC R
  Build.and.Save.models <- function(
              dir = image.cropped.to.training.dir,
              modelBuildingData = "modelBuildingData.rds",
              models.dir = Models.dir){

      dat <- readRDS(str_c(dir,"/",modelBuildingData)) %>%
          dplyr::select(-zone)


      names <- colnames(dat)
      names <- str_replace(names, "\\(",".")
      names <- str_replace(names, "\\)",".")
      names <- str_replace(names, "\\:",".")
      colnames(dat) <- names

            dat_G <- dat %>%
                mutate(Class = as.character(Class),
                       Class = ifelse(Class == "G", Class, "O"))

            dat_I <- dat %>%
                mutate(Class = as.character(Class),
                       Class = ifelse(Class == "I", Class, "O"))

            dat_T <- dat %>%
                mutate(Class = as.character(Class),
                       Class = ifelse(Class == "T", Class, "O"))

          # Create Tasks
      all.task <- makeClassifTask(id = paste0(image.name,"_all"), data = dat, target = "Class")
      grass.task <- makeClassifTask(id = paste0(image.name,"_grass"), data = dat_G, target = "Class")
      impervious.task <- makeClassifTask(id = paste0(image.name,"_impervious"), data = dat_I, target = "Class")
      tree.task <- makeClassifTask(id = paste0(image.name,"_tree"), data = dat_T, target = "Class",positive = "T")

      task.list <- list(all = all.task, grass = grass.task, impervious = impervious.task, tree = tree.task)

                                                 # Make Learners
         RF_prob <- makeLearner(id = "rf_prob","classif.randomForest", predict.type = "prob", fix.factors.prediction = TRUE)
         RF_response <- makeLearner(id = "rf_resp", "classif.randomForest", predict.type = "response", fix.factors.prediction = TRUE)
         SVM_response <- makeLearner(id = "svm_resp", "classif.svm", predict.type = "response", fix.factors.prediction = TRUE)

         learner_list <- list(RF_prob = RF_prob, RF_response = RF_response, SVM_response = SVM_response)

                                                 # Train Learners on Tasks, Make models
         cl<-makeCluster(cores)
         registerDoParallel(cl)
         models <- foreach(task = task.list, .packages = "mlr") %:%
             foreach(learner = learner_list) %dopar% {
                 train(learner, task)
             }
       saveRDS(models, file = paste0(models.dir,"/models.rds"))
  }
#+END_SRC

#+RESULTS:

*** Classify Raster
#+BEGIN_SRC R

classify.raster <- function(segment.feature.df.dir,
                                segment.dir,
                                model.dir,
                                model.name.rds = "models",
                                segment.feature.appendage = segment.feature.df.name.append,
                                segmentation.appendage = segment.tile.name.append,
                                classify.out.dir,
                                tile.name = i) {
        df <- readRDS(paste0(segment.feature.df.dir,"/",tile.name,segment.feature.appendage,".rds"))
        models <-readRDS(paste0(model.dir,"/",model.name.rds,".rds"))
        umod <- unlist(models, recursive = F)
        seg.path <- paste0(segment.dir,"/",tile.name,segment.tile.name.append,".tif")
        seg <- raster(seg.path)
#	dfRowsWithNA <- which(is.na(df[,2]))
	complete.df <- df[complete.cases(df),] # svm can't predict with NAs
        lapply(umod, function(mod) {
            pred <- predict(mod, newdata = complete.df)
            response <- factor(as.character(pred$data$response), levels = c("G","I","T","O"))
            m <- cbind(zone = complete.df$segment, response)
            m <- left_join(as.data.frame(df["segment"]), as.data.frame(m), by = c("segment" = "zone"))
            r <- reclassify(seg, m)
    #        x <- data.frame(ID = 1:4, LandCover = c("G","I","T","O")) %>%
    #            filter(LandCover %in% levels(factor(response)))
    #        levels(r) <- x
            if (ncol(pred$data) > 2) {
                prob <- (pred$data[,grep("prob.*", x = colnames(pred$data))]) # get columns that contain probabilities
                ProbOfClass <- apply(prob, MARGIN = 1, FUN = max)
                m <- cbind(segment = df$segment, ProbOfClass)
                m <- left_join(as.data.frame(df["segment"]), as.data.frame(m))
                p <- reclassify(seg, m)
                r <- stack(r,p)
            }
            path <- paste0(segment.dir,"/",tile.name,"_",mod$task.desc$id,"_",mod$learner$id,".tif")
            writeRaster(r, path, overwrite=TRUE)
            print(path)
        })
  }

#+END_SRC

#+RESULTS:

** Libraries
#+BEGIN_SRC R
library(mlr)
library(broom)
library(rgdal)
library(raster)
library(plyr)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
library(foreach)
library(doParallel)
#+END_SRC

#+RESULTS:
#+begin_example
Loading required package: BBmisc
Loading required package: ggplot2
Loading required package: ParamHelpers
Loading required package: sp
rgdal: version: 1.0-4, (SVN revision 548)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 1.10.0, released 2013/04/24
 Path to GDAL shared files: /usr/share/gdal/1.10
 Loaded PROJ.4 runtime: Rel. 4.8.0, 6 March 2012, [PJ_VERSION: 480]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.1-1

Attaching package: ‘raster’

The following object is masked from ‘package:mlr’:

    resample

The following object is masked from ‘package:ParamHelpers’:

    getValues

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following objects are masked from ‘package:raster’:

    intersect, select, union

The following object is masked from ‘package:BBmisc’:

    collapse

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Attaching package: ‘tidyr’

The following object is masked from ‘package:raster’:

    extract
foreach: simple, scalable parallel programming from Revolution Analytics
Use Revolution R for scalability, fault tolerance and more.
http://www.revolutionanalytics.com
Loading required package: iterators
Loading required package: parallel
#+end_example

** NAIP
*** Inputs

**** Input Directories
#+BEGIN_SRC R
# input directories
image.dir <- "../RD_NAIP"

pca.dir <- "../RD_PCA_Regions"
training.dir <- "../RD_Training_Regions"

accuracy.dir <- "../RD_Accuracy"

grids.accuracy.dir <- str_c(accuracy.dir, "/Grids")
fieldplots.accuracy.dir<- str_c(accuracy.dir, "/FieldData")

crop.dir <- "../RD_CroplandDataLayer"
water.dir <- "../RD_WI-waterbody-24k"
urban.dir <- "../RD_US_UrbanAreasShapefile"
urban.and.incorporated.dir <- "../RD_merged_WIurbanAreas_and_incorporatedAreas"
#+END_SRC

#+RESULTS:

**** Image Names and Paths

#+BEGIN_SRC R
image.name <- "madison"
image.path <- str_c(image.dir, "/", image.name, ".tif")

ratio.tile.name.append <- "_with_ratios"
pca.tile.name.append <- "_pca"
segment.tile.name.append <- "_N-30_C-15"
segment.feature.df.name.append <- "_SegmentFeatureDF"
#+END_SRC
#+RESULTS:

**** Input Shapefile DSNs and Layers
#+BEGIN_SRC R

pca.region.dsn <- "../RD_PCA_Regions/Madison_PCA_Regions"
pca.region.layer <- "PCA_regions"

training.region.dsn <- "../RD_Training_Regions/Madison_TrainingRegions"
training.region.layer <- "madisonTrainingPolygons"

grid.accuracy.region.dsn <- "../RD_Accuracy/Grids"
grid.accuracy.region.layer <- "ufia-grid-points"

grid.accuracy.truthFromAndy.csvpath <- str_c(grid.accuracy.region.dsn,"grid_accuracy_assessment_andy.csv")

#+END_SRC

#+RESULTS:


**** Derived Directories
#+BEGIN_SRC R
# make derived data directory
derived.dir <- "../DD"
dir.create(derived.dir)

derived.image.dir <- str_c(derived.dir, "/", image.name)
dir.create(derived.image.dir)

image.cropped.to.training.dir <- str_c(derived.dir, "/", image.name, "/training")
dir.create(image.cropped.to.training.dir)

image.cropped.to.pca.dir <- str_c(derived.dir, "/", image.name, "/pca")
dir.create(image.cropped.to.pca.dir)

image.cropped.to.accuracy.dir <- str_c(derived.dir, "/", image.name, "/Accuracy")
dir.create(image.cropped.to.accuracy.dir)

image.cropped.to.grid.accuracy.dir <- str_c(image.cropped.to.accuracy.dir,"/Grids")
dir.create(image.cropped.to.grid.accuracy.dir)

ManuallyClassifiedTrainingPolygons.dir <- paste0(derived.image.dir,"/","ManuallyClassifiedTrainingPolygons")
dir.create(ManuallyClassifiedTrainingPolygons.dir)

Models.dir <- paste0(derived.image.dir,"/","Models")
dir.create(Models.dir)
#+END_SRC

#+RESULTS:
#+begin_example
Warning message:
In dir.create(derived.dir) : '../DD' already exists
Warning message:
In dir.create(derived.image.dir) : '../DD/madison' already exists
Warning message:
In dir.create(image.cropped.to.training.dir) :
  '../DD/madison/training' already exists
Warning message:
In dir.create(image.cropped.to.pca.dir) :
  '../DD/madison/pca' already exists
Warning message:
In dir.create(image.cropped.to.accuracy.dir) :
  '../DD/madison/Accuracy' already exists
Warning message:
In dir.create(image.cropped.to.grid.accuracy.dir) :
  '../DD/madison/Accuracy/Grids' already exists
Warning message:
In dir.create(ManuallyClassifiedTrainingPolygons.dir) :
  '../DD/madison/ManuallyClassifiedTrainingPolygons' already exists
Warning message:
In dir.create(Models.dir) : '../DD/madison/Models' already exists
#+end_example

**** Derived Shapefile DSNs and Layers
#+BEGIN_SRC R
training.region.imageCRS.dsn <- str_c(derived.image.dir,"/Madison_TrainingRegions")
dir.create(training.region.imageCRS.dsn)

pca.region.imageCRS.dsn <- str_c(derived.image.dir,"/Madison_PCA_Regions")
dir.create(pca.region.imageCRS.dsn)

grid.accuracy.region.imageCRS.dsn <- str_c(derived.image.dir,"/Madison_GridAccuracy_Regions")
dir.create(grid.accuracy.region.imageCRS.dsn)


#+END_SRC

#+RESULTS:
: Warning message:
: In dir.create(training.region.imageCRS.dsn) :
:   '../DD/madison/Madison_TrainingRegions' already exists
: Warning message:
: In dir.create(pca.region.imageCRS.dsn) :
:   '../DD/madison/Madison_PCA_Regions' already exists
: Warning message:
: In dir.create(grid.accuracy.region.imageCRS.dsn) :
:   '../DD/madison/Madison_GridAccuracy_Regions' already exists


**** number of cores
#+BEGIN_SRC R
cores <- 15
#+END_SRC

#+RESULTS:


*** make pca model to tranform images for slic segmentation algorithm.
**** Reproject PCA Region Shapefile to Image

#+BEGIN_SRC R

  Reproject_Shapefile_to_Image_CRS(pca.region.dsn,
                                   pca.region.layer,
                                   image.path,
				   pca.region.imageCRS.dsn)


#+END_SRC

#+RESULTS:
:  OGR data source with driver: ESRI Shapefile
: Source: "../RD_PCA_Regions/Madison_PCA_Regions", layer: "PCA_regions"
: with 8 features
: It has 1 fields

**** Crop image to create a smaller image around each of the polygons

#+BEGIN_SRC R

  Crop_image_to_each_Shapefile_polygon(pca.region.imageCRS.dsn,
                                       pca.region.layer,
                                       image.path,
                                       cores = cores,
                                       output.dir = image.cropped.to.pca.dir)

#+END_SRC

#+RESULTS:
#+begin_example
 OGR data source with driver: ESRI Shapefile
Source: "../DD/madison/Madison_PCA_Regions", layer: "PCA_regions"
with 8 features
It has 1 fields
[[1]]
class       : RasterBrick
dimensions  : 392, 561, 219912, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 300906, 301467, 4770791, 4771183  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/1.tif
names       : X1.1, X1.2, X1.3, X1.4
min values  :   36,   39,   53,   42
max values  :  242,  244,  235,  234


[[2]]
class       : RasterBrick
dimensions  : 588, 661, 388668, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 301647, 302308, 4770758, 4771346  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/2.tif
names       : X2.1, X2.2, X2.3, X2.4
min values  :   36,   41,   52,   45
max values  :  241,  243,  237,  229


[[3]]
class       : RasterBrick
dimensions  : 478, 542, 259076, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 306759, 307301, 4773086, 4773564  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/3.tif
names       : X3.1, X3.2, X3.3, X3.4
min values  :   28,   34,   51,   51
max values  :  246,  248,  237,  246


[[4]]
class       : RasterBrick
dimensions  : 246, 252, 61992, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 307511, 307763, 4772422, 4772668  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/4.tif
names       : X4.1, X4.2, X4.3, X4.4
min values  :    0,    0,    0,    0
max values  :  243,  243,  227,  225


[[5]]
class       : RasterBrick
dimensions  : 406, 489, 198534, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 308697, 309186, 4773470, 4773876  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/5.tif
names       : X5.1, X5.2, X5.3, X5.4
min values  :   32,   38,   63,   63
max values  :  245,  247,  247,  213


[[6]]
class       : RasterBrick
dimensions  : 333, 437, 145521, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 310986, 311423, 4773457, 4773790  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/6.tif
names       : X6.1, X6.2, X6.3, X6.4
min values  :   32,   39,   57,   69
max values  :  244,  246,  242,  215


[[7]]
class       : RasterBrick
dimensions  : 578, 590, 341020, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 312891, 313481, 4773127, 4773705  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/7.tif
names       : X7.1, X7.2, X7.3, X7.4
min values  :   29,   38,   52,   68
max values  :  252,  251,  249,  233


[[8]]
class       : RasterBrick
dimensions  : 642, 1231, 790302, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 296632, 297863, 4772061, 4772703  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/8.tif
names       : X8.1, X8.2, X8.3, X8.4
min values  :   36,   40,   46,   37
max values  :  247,  246,  236,  227
#+end_example



***** Start R Loop, for every smaller image, do in parallel, :
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.pca.dir) %>%
      str_extract(., pattern = "[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr")) %dopar% {
#+END_SRC

#+RESULTS:

**** Add Ratios
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.pca.dir) %>%
      str_extract(., pattern = "[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr")) %dopar% {

  add.ratios.ndvi(tile.dir = image.cropped.to.pca.dir,
                  tile.name = i)
}
#+END_SRC

#+RESULTS:
#+begin_example
[[1]]
class       : RasterBrick
dimensions  : 392, 561, 219912, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 300906, 301467, 4770791, 4771183  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/1_with_ratios.tif
names       : X1_with_ratios.1, X1_with_ratios.2, X1_with_ratios.3, X1_with_ratios.4, X1_with_ratios.5, X1_with_ratios.6, X1_with_ratios.7, X1_with_ratios.8, X1_with_ratios.9
min values  :               36,               39,               53,               42,               24,               27,               25,               27,               62
max values  :              242,              244,              235,              234,               69,               65,               79,              107,              152


[[2]]
class       : RasterBrick
dimensions  : 392, 561, 219912, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 300906, 301467, 4770791, 4771183  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/1_with_ratios.tif
names       : X1_with_ratios.1, X1_with_ratios.2, X1_with_ratios.3, X1_with_ratios.4, X1_with_ratios.5, X1_with_ratios.6, X1_with_ratios.7, X1_with_ratios.8, X1_with_ratios.9
min values  :               36,               39,               53,               42,               24,               27,               25,               27,               62
max values  :              242,              244,              235,              234,               69,               65,               79,              107,              152


[[3]]
class       : RasterBrick
dimensions  : 588, 661, 388668, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 301647, 302308, 4770758, 4771346  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/2_with_ratios.tif
names       : X2_with_ratios.1, X2_with_ratios.2, X2_with_ratios.3, X2_with_ratios.4, X2_with_ratios.5, X2_with_ratios.6, X2_with_ratios.7, X2_with_ratios.8, X2_with_ratios.9
min values  :               36,               41,               52,               45,               24,               28,               27,               25,               54
max values  :              241,              243,              237,              229,               87,               67,               78,              106,              151


[[4]]
class       : RasterBrick
dimensions  : 478, 542, 259076, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 306759, 307301, 4773086, 4773564  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/3_with_ratios.tif
names       : X3_with_ratios.1, X3_with_ratios.2, X3_with_ratios.3, X3_with_ratios.4, X3_with_ratios.5, X3_with_ratios.6, X3_with_ratios.7, X3_with_ratios.8, X3_with_ratios.9
min values  :               28,               34,               51,               51,               14,               23,               29,               27,               56
max values  :              246,              248,              237,              246,               76,               72,               88,              104,              151


[[5]]
class       : RasterBrick
dimensions  : 246, 252, 61992, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 307511, 307763, 4772422, 4772668  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/4_with_ratios.tif
names       : X4_with_ratios.1, X4_with_ratios.2, X4_with_ratios.3, X4_with_ratios.4, X4_with_ratios.5, X4_with_ratios.6, X4_with_ratios.7, X4_with_ratios.8, X4_with_ratios.9
min values  :                0,                0,                0,                0,               14,               23,               28,               21,               52
max values  :              243,              243,              227,              225,               87,               87,               85,               99,              149


[[6]]
class       : RasterBrick
dimensions  : 406, 489, 198534, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 308697, 309186, 4773470, 4773876  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/5_with_ratios.tif
names       : X5_with_ratios.1, X5_with_ratios.2, X5_with_ratios.3, X5_with_ratios.4, X5_with_ratios.5, X5_with_ratios.6, X5_with_ratios.7, X5_with_ratios.8, X5_with_ratios.9
min values  :               32,               38,               63,               63,               22,               25,               30,               32,               69
max values  :              245,              247,              247,              213,               76,               63,               87,              105,              147


[[7]]
class       : RasterBrick
dimensions  : 333, 437, 145521, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 310986, 311423, 4773457, 4773790  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/6_with_ratios.tif
names       : X6_with_ratios.1, X6_with_ratios.2, X6_with_ratios.3, X6_with_ratios.4, X6_with_ratios.5, X6_with_ratios.6, X6_with_ratios.7, X6_with_ratios.8, X6_with_ratios.9
min values  :               32,               39,               57,               69,               23,               27,               27,               36,               74
max values  :              244,              246,              242,              215,               76,               62,               76,              106,              149


[[8]]
class       : RasterBrick
dimensions  : 578, 590, 341020, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 312891, 313481, 4773127, 4773705  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/7_with_ratios.tif
names       : X7_with_ratios.1, X7_with_ratios.2, X7_with_ratios.3, X7_with_ratios.4, X7_with_ratios.5, X7_with_ratios.6, X7_with_ratios.7, X7_with_ratios.8, X7_with_ratios.9
min values  :               29,               38,               52,               68,               19,               28,               28,               18,               44
max values  :              252,              251,              249,              233,               67,               69,               83,              108,              153


[[9]]
class       : RasterBrick
dimensions  : 642, 1231, 790302, 9  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 296632, 297863, 4772061, 4772703  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/pca/8_with_ratios.tif
names       : X8_with_ratios.1, X8_with_ratios.2, X8_with_ratios.3, X8_with_ratios.4, X8_with_ratios.5, X8_with_ratios.6, X8_with_ratios.7, X8_with_ratios.8, X8_with_ratios.9
min values  :               36,               40,               46,               37,               24,               28,               27,               10,               28
max values  :              247,              246,              236,              227,               75,               78,               82,              107,              154
#+end_example

**** Create and Save PCA model/rotation
#+BEGIN_SRC R
  pca <- make.and.save.pca.transformation(image.dir = image.cropped.to.pca.dir,
                                          band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")
                                     )
#+END_SRC

#+RESULTS:
:  There were 15 warnings (use warnings() to see them)

*** Make SegmentationFeatureDFs for Training Regions
1) Input
   - Testing Region Shapefiles
   - image
2) Operation
   - Reproject Shapefiles to that of image
   - Crop image to each polygon in the shapefile
   - Derive SegmentationFeatureDF from each tile of the image in region of each polygon
3) Output
   - SegmentationFeatureDFs for every training polygon

**** Reproject Training Region Shapefile to Image
#+BEGIN_SRC R
  Reproject_Shapefile_to_Image_CRS(training.region.dsn,
                                   training.region.layer,
                                   image.path,
				   training.region.imageCRS.dsn)
#+END_SRC

#+RESULTS:
:  OGR data source with driver: ESRI Shapefile
: Source: "../RD_Training_Regions/Madison_TrainingRegions", layer: "madisonTrainingPolygons"
: with 15 features
: It has 1 fields
: Error in writeOGR(shapefile.WimageCRS, shapefile.out.dsn, shapefile.layer,  (from utc.org[*Org Src utc.org[ R ]*]!19506Pof#8) :
:   layer exists, use a new layer name

**** Crop image to create a smaller image around each of the testing polygons

#+BEGIN_SRC R

  Crop_image_to_each_Shapefile_polygon(training.region.imageCRS.dsn,
                                       training.region.layer,
                                       image.path,
                                       cores = cores,
                                       output.dir = image.cropped.to.training.dir)

#+END_SRC

#+RESULTS:
#+begin_example
 OGR data source with driver: ESRI Shapefile
Source: "../DD/Madison_TrainingRegions", layer: "madisonTrainingPolygons"
with 15 features
It has 1 fields
[[1]]
class       : RasterBrick
dimensions  : 138, 135, 18630, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 320425, 320560, 4772462, 4772600  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/1.tif
names       : X1.1, X1.2, X1.3, X1.4
min values  :   26,   34,   58,   73
max values  :  239,  243,  225,  220


[[2]]
class       : RasterBrick
dimensions  : 198, 462, 91476, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 297406, 297868, 4767289, 4767487  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/2.tif
names       : X2.1, X2.2, X2.3, X2.4
min values  :   34,   43,   61,   39
max values  :  239,  241,  219,  219


[[3]]
class       : RasterBrick
dimensions  : 411, 345, 141795, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 307180, 307525, 4772729, 4773140  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/3.tif
names       : X3.1, X3.2, X3.3, X3.4
min values  :   44,   52,   67,   50
max values  :  247,  249,  241,  252


[[4]]
class       : RasterBrick
dimensions  : 309, 276, 85284, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 310145, 310421, 4773362, 4773671  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/4.tif
names       : X4.1, X4.2, X4.3, X4.4
min values  :   34,   42,   62,   61
max values  :  242,  245,  234,  213


[[5]]
class       : RasterBrick
dimensions  : 304, 192, 58368, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 311294, 311486, 4774332, 4774636  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/5.tif
names       : X5.1, X5.2, X5.3, X5.4
min values  :   36,   45,   70,   61
max values  :  246,  247,  245,  212


[[6]]
class       : RasterBrick
dimensions  : 183, 203, 37149, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 311757, 311960, 4774145, 4774328  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/6.tif
names       : X6.1, X6.2, X6.3, X6.4
min values  :   35,   41,   60,   66
max values  :  238,  239,  230,  215


[[7]]
class       : RasterBrick
dimensions  : 576, 397, 228672, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 297236, 297633, 4771529, 4772105  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/7.tif
names       : X7.1, X7.2, X7.3, X7.4
min values  :   36,   40,   58,   37
max values  :  238,  235,  212,  228


[[8]]
class       : RasterBrick
dimensions  : 480, 486, 233280, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 295362, 295848, 4772706, 4773186  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/8.tif
names       : X8.1, X8.2, X8.3, X8.4
min values  :   34,   43,   51,   44
max values  :  252,  251,  244,  233


[[9]]
class       : RasterBrick
dimensions  : 421, 396, 166716, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 296178, 296574, 4770834, 4771255  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/9.tif
names       : X9.1, X9.2, X9.3, X9.4
min values  :   45,   49,   52,   46
max values  :  253,  252,  241,  231


[[10]]
class       : RasterBrick
dimensions  : 185, 473, 87505, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 299572, 300045, 4769169, 4769354  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/10.tif
names       : X10.1, X10.2, X10.3, X10.4
min values  :    38,    42,    58,    45
max values  :   244,   246,   229,   229


[[11]]
class       : RasterBrick
dimensions  : 320, 317, 101440, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 301052, 301369, 4767681, 4768001  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/11.tif
names       : X11.1, X11.2, X11.3, X11.4
min values  :    35,    39,    52,    65
max values  :   124,   150,    96,   231


[[12]]
class       : RasterBrick
dimensions  : 220, 216, 47520, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 301870, 302086, 4767743, 4767963  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/12.tif
names       : X12.1, X12.2, X12.3, X12.4
min values  :    56,    84,    69,   155
max values  :   150,   174,   125,   225


[[13]]
class       : RasterBrick
dimensions  : 570, 494, 281580, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 299701, 300195, 4767461, 4768031  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/13.tif
names       : X13.1, X13.2, X13.3, X13.4
min values  :    40,    44,    60,    40
max values  :   242,   244,   241,   230


[[14]]
class       : RasterBrick
dimensions  : 317, 530, 168010, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 304203, 304733, 4767016, 4767333  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/14.tif
names       : X14.1, X14.2, X14.3, X14.4
min values  :    45,    55,    67,    45
max values  :   246,   248,   245,   248


[[15]]
class       : RasterBrick
dimensions  : 361, 755, 272555, 4  (nrow, ncol, ncell, nlayers)
resolution  : 1, 1  (x, y)
extent      : 307670, 308425, 4774407, 4774768  (xmin, xmax, ymin, ymax)
coord. ref. : +proj=utm +zone=16 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs
data source : /data2/erker-data2/Pjt_UTC/DD/madison/training/15.tif
names       : X15.1, X15.2, X15.3, X15.4
min values  :    33,    38,    56,    50
max values  :   248,   249,   245,   254


There were 30 warnings (use warnings() to see them)
#+end_example


**** Create Segment Feature Dataframe for each of these smaller images
***** Start R Loop, for every smaller image, do in parallel, :
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.training.dir) %>%
      str_extract(., pattern = "[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr")) %dopar% {
#+END_SRC

#+RESULTS:

***** Add Ratios
#+BEGIN_SRC R
  add.ratios.ndvi(tile.dir = image.cropped.to.training.dir,
                  tile.name = i)
#+END_SRC

#+RESULTS:

***** Perform PCA
#+BEGIN_SRC R
  image.pca(image.dir = image.cropped.to.training.dir,
            image.name = i)

#+END_SRC
***** End loop
#+BEGIN_SRC R :results none
}

#+END_SRC

***** Segmentation
#+NAME: training.dir
#+BEGIN_SRC R
message(image.cropped.to.training.dir)
#+END_SRC


#+BEGIN_SRC sh :var dir=training.dir
  cd $dir
  # pixel size
  # desired area for superpixel/segments
  # compactness value
  # directory
  python ../../../code/fia_segment_cmdArgs.py 1 30 15
#+END_SRC

#+RESULTS:
| average     | number    | of        | pixels | per                                            | segment | is | 30 |
| compactness | parameter | is        | 15     |                                                |         |    |    |
| the         | image     | directory | is     | /data2/erker-data2/Pjt_UTC/DD/madison/training |         |    |    |

***** Create Segment Feature Dataframe
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.training.dir) %>%
      str_extract(., pattern = "[0-9]+_N-[0-9]+_C-[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr","dplyr","broom","tidyr")) %dopar% {
               Create.Segment.Feature.df(image.dir = image.cropped.to.training.dir,
                                         image.name = i)}
#+END_SRC

#+RESULTS:
#+begin_example
[[1]]
NULL

[[2]]
NULL

[[3]]
NULL

[[4]]
NULL

[[5]]
NULL

[[6]]
NULL

[[7]]
NULL

[[8]]
NULL

[[9]]
NULL

[[10]]
NULL

[[11]]
NULL

[[12]]
NULL

[[13]]
NULL

[[14]]
NULL

[[15]]
NULL

[[16]]
NULL

[[17]]
NULL

[[18]]
NULL

[[19]]
NULL

[[20]]
NULL

[[21]]
NULL

[[22]]
NULL

[[23]]
NULL

[[24]]
NULL

[[25]]
NULL

[[26]]
NULL

[[27]]
NULL

[[28]]
NULL

[[29]]
NULL

[[30]]
NULL

[[31]]
NULL
#+end_example

*** Supervised Classification/ manual classification of segmentation polygons
1) Input
   - Segmentation Layer from the Training Regions
2) Operation
   - Convert Segmentation Layer to Polygons
   - Classify this manually in QGIS and save as Classified Polygons
3) Output
   - Classified segmentation polygons

**** Convert Segmentation Layer to Polygons
#+BEGIN_SRC R :results none
    image.names <- list.files(image.cropped.to.training.dir) %>%
        str_extract(., pattern = "[0-9]+_N-[0-9]+_C-[0-9]+.tif") %>%
        str_extract(., pattern = "[0-9]+") %>%
        na.omit()

    cl <- makeCluster(cores)
    registerDoParallel(cl)


    foreach (i = image.names, .packages = c("raster","sp","gdalUtils")) %dopar% {
        polygonize.and.add.Class(image.dir = image.cropped.to.training.dir,
                                 image.name = i)
  }

#+END_SRC

**** Manually Classify Polygons

If this gets evaluated it will copy over the manually classified
training polygons.  Don't evaluate unless you want to erase the
training polygons within.

#+BEGIN_SRC sh :eval no
#cp ../DD/madison/training/*/*.shp ../DD/madison/ManuallyClassifiedTrainingPolygons
#cp ../DD/madison/training/*/*.dbf ../DD/madison/ManuallyClassifiedTrainingPolygons
#cp ../DD/madison/training/*/*.shx ../DD/madison/ManuallyClassifiedTrainingPolygons
#+END_SRC

#+RESULTS:

*** Create Models
1) Input
   - SegmentationFeaturesDF
   - Manually/Supervised classified segmentation polygons from
     training regions

2) Operation
   - Merge Training polygons Class with Segmentationfeatures
   - Build Models using mlr
     - untuned
     - tuned

3) Output
   - Models for classifying images
     - RF or SVM (2 options)
       - All 3 classes in one model, or just one class in a model (4 options)
	 - Highly tuned or default parameters (2 options)
   - 2 * 4 * 2 = 16
**** Merge Training Polygons with Segment Feature dataframe
#+BEGIN_SRC R
  create.df.toBuildModel.fromTrainingPolygons.and.SegmentFeatureDFs(manuallyClassifiedPolygondir = ManuallyClassifiedTrainingPolygons.dir,
                                                                    image.dir = image.cropped.to.training.dir)
#+END_SRC

**** Build and Save models

#+BEGIN_SRC R

  Build.and.Save.models(dir = image.cropped.to.training.dir,
                        modelBuildingData = "modelBuildingData.rds",
                        models.dir = Models.dir)



#+END_SRC

#+RESULTS:


#+BEGIN_SRC R
    rdesc <- makeResampleDesc("CV", iters = 3)

    r <- resample(learner = SVM_response, task = all.task, resampling = rdesc)

    rf <- models[[1]][[1]]

    p <- predict(rf, task = all.task)


#+END_SRC

***** some graphic explorations
#+BEGIN_SRC R :results graphics :file figs/pairs.png :eval no
    library(GGally)

  #  dat2 <- rename(dat, "xy.inter" = `x:y`)
  names <- colnames(dat)
  names <- str_replace(names, "\\(",".")
  names <- str_replace(names, "\\)",".")

colnames(dat) <- names

    ggpairs(dat)


#+END_SRC
#+BEGIN_SRC R :results graphics :file figs/byGroup.png :height 2000 :width 200 :eval no
  dat.g <- gather(dat, key = band, value = value, -Class, -zone)
  ggplot(dat.g, aes(x = Class, y = value)) + geom_boxplot() + facet_grid(band~1, scales = "free")
#+END_SRC

 #+BEGIN_SRC R

 #+END_SRC


*** Classify Testing Regions
**** Grids
1) Input
   - Classification Models
   - Testing Region Shapefiles
   - image
2) Operation
   - Reproject Shapefiles to that of image
   - Crop image to each polygon in the shapefile
   - For each possible model Classify each tile of the image in region of each polygon
3) Output
   - classified images for each model for each grid polygon
   - see directory structure, "Testing" header

***** Reproject Training Region Shapefile to Image
#+BEGIN_SRC R
  Reproject_Shapefile_to_Image_CRS(grid.accuracy.region.dsn,
                                   grid.accuracy.region.layer,
                                   image.path,
				   grid.accuracy.region.imageCRS.dsn)
#+END_SRC

#+RESULTS:
:  OGR data source with driver: ESRI Shapefile
: Source: "../RD_Accuracy/Grids", layer: "ufia-grid-points"
: with 6750 features
: It has 1 fields

***** Crop image to create a smaller image around each of the accuracy polygons

#+BEGIN_SRC R :results none
  Crop_image_to_regions_around_points(grid.accuracy.region.imageCRS.dsn,
                                       grid.accuracy.region.layer,
                                       image.path,
                                       cores = cores,
                                       output.dir = image.cropped.to.grid.accuracy.dir)

#+END_SRC

***** Classify images
****** Start R Loop, for every smaller image, do in parallel, :
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.grid.accuracy.dir) %>%
      str_extract(., pattern = "[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr")) %dopar% {
#+END_SRC

#+RESULTS:

****** Add Ratios
#+BEGIN_SRC R
  add.ratios.ndvi(tile.dir = image.cropped.to.grid.accuracy.dir,
                  tile.name = i)
#+END_SRC

#+RESULTS:

****** Perform PCA
#+BEGIN_SRC R

  image.pca(image.dir = image.cropped.to.grid.accuracy.dir,
            image.name = i)

#+END_SRC
****** End loop
#+BEGIN_SRC R :results none
}

#+END_SRC

****** Segmentation

#+NAME: grid.accuracy.dir
#+BEGIN_SRC R
message(image.cropped.to.grid.accuracy.dir)
#+END_SRC

#+RESULTS: grid.accuracy.dir
: ../DD/madison/Accuracy/Grids


#+BEGIN_SRC sh :var dir=grid.accuracy.dir
  cd $dir
pwd
# pixel size
  # desired area for superpixel/segments
  # compactness value
  # directory
  python ../../../../code/fia_segment_cmdArgs.py 1 30 15
#+END_SRC

#+RESULTS:
| /home/erker/mydata2/Pjt_UTC/DD/madison/Accuracy/Grids |           |           |        |                                                      |         |    |    |
| average                                               | number    | of        | pixels | per                                                  | segment | is | 30 |
| compactness                                           | parameter | is        | 15     |                                                      |         |    |    |
| the                                                   | image     | directory | is     | /data2/erker-data2/Pjt_UTC/DD/madison/Accuracy/Grids |         |    |    |

****** Start R Loop, for every smaller image, do in parallel, :
#+BEGIN_SRC R
  image.names <- list.files(image.cropped.to.grid.accuracy.dir) %>%
      str_extract(., pattern = "^[0-9]+.tif") %>%
      str_extract(., pattern = "[0-9]+") %>%
      na.omit()

  cl <- makeCluster(cores)
  registerDoParallel(cl)

  foreach (i = image.names,
           .packages = c("raster","stringr","dplyr","broom","tidyr","foreach","mlr")) %dopar% {
#+END_SRC

#+RESULTS:

****** Create Segment Feature Dataframe
#+BEGIN_SRC R :results none
               Create.Segment.Feature.df(image.dir = image.cropped.to.grid.accuracy.dir,
                                         image.name = i)
#+END_SRC

****** Predict Class of each Segment and create classified images
#+BEGIN_SRC R :results none

                     classify.raster(segment.feature.df.dir = image.cropped.to.grid.accuracy.dir,
                        model.dir = Models.dir,
                        segment.dir = image.cropped.to.grid.accuracy.dir,
                        classify.out.dir = image.cropped.to.grid.accuracy.dir,
                        tile.name = i,
                        segmentation.appendage = segment.tile.name.append,
                        model.name.rds = "models",
                        segment.feature.appendage = segment.feature.df.name.append)

                 }

  stopCluster(cl)

#+END_SRC

**** Fieldplot
*** Assess Accuracy
**** Grid
1) Input:
   - classified images for each model for each grid polygon
   - Grid Shapefile

2) Operation
   - For the 4 different grid sizes (50x50, 100x100, 150x150, 200x200)
   - Depending on the Model Target (all three cover types or a single
     cover type), calculate the proportion of cover in the classified image.
   - Calculate Proportion of cover within the grid shapefile
   - Combine shapefile information with classified image information
     and create RMSEs and plots.

3) Output

   - Table of Accuracy by model and grid size
   - RMSE plots


***** Calculate the cover of each grid

The grids, that are 200mx200m will have 8 sizes, smaller grids will
have fewer.

Grid sizes : 25x25, 50x50,75x75,100x100,125x125,150x150,175x175,200x200


| Grid Number | Grid Size | % T | % G | % I |
|-------------+-----------+-----+-----+-----|
| 1           |           |     |     |     |
| 1           |           |     |     |     |
|             |           |     |     |     |














**** Fieldplot

Same as with Grid, but adjust the definitions of "tree" in the field
data and see how accuracy varies.

**** Combine NAIP Accuracy Assessments




** SPOT
Change image specfic inputs like image.path, and rerun code for NAIP
#+BEGIN_SRC R
spot.image.dir <- "../RD_SPOT"
spot.image.path <- str_c(spot.image.dir, "/", spot.image.name, ".tif")
spot.image.name <- "geomatica_SPOT_panshp"
#+END_SRC

** Combine Accuracy Assessment Results


** Classify Every Urban Area in the State











