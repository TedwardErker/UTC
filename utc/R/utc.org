#+TITLE:Functions to Map Urban Tree Canopy
#+AUTHOR: Tedward Erker
#+email: erker@wisc.edu
#+PROPERTY: header-args:R :cache no :results output :exports both :tangle utc.R :session *R:utc*
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
------------
* Functions
** miscellaneous
*** Extract Name from path
#+BEGIN_SRC R
      # Use basename instead!
        extract.name.from.path <- function(path) {
            str_extract(basename(path), "[A-Za-z0-9_]*.") %>%
                str_sub(.,1,-2)
        }

#+END_SRC

#+RESULTS:
*** Reproject Shapefile to Image Coordinate Reference System
#+BEGIN_SRC R

  Reproject_Shapefile_to_Image_CRS <- function(shapefile.dsn,
                                               shapefile.layer,
                                               image.path,
                                               shapefile.out.dsn) {
      r <- stack(image.path)
      shapefile <- readOGR(shapefile.dsn, shapefile.layer)
      shapefile.WimageCRS <- spTransform(shapefile, crs(r))
      image.name <- extract.name.from.path(image.path)
      shapefile.layer  <- str_c(image.name,"_",shapefile.layer)
      writeOGR(shapefile.WimageCRS, shapefile.out.dsn, shapefile.layer, driver = "ESRI Shapefile", overwrite =T)
  }
#+END_SRC

#+RESULTS:
** Crop Image

*** Crop image to each Shapefile polygon
#+BEGIN_SRC R
  Crop_image_to_each_Shapefile_polygon <- function(shapefile.dsn,
                                                     shapefile.layer,
                                                     image.path,
                                                     cores,
                                                     output.dir)  {
        image.name <- extract.name.from.path(image.path)
        shape <- readOGR(shapefile.dsn, str_c(image.name,"_",shapefile.layer))
        polygons <- as(shape, "SpatialPolygons")

        image <- stack(image.path)

        cl <- makeCluster(cores)
        registerDoParallel(cl)

        foreach (i = seq_along(polygons),
                 .packages = c("raster")) %dopar% {
                     r <- image
                     r <- crop(r, polygons[i])
                     writeRaster(r, paste0(output.dir,"/",image.name,".",i,".tif"),
                                 overwrite = T)
                 }
    }

#+END_SRC

#+RESULTS:

*** Crop image to regions around shapefile points
#+BEGIN_SRC R

                                          # assign the polygon name to the points.
  give_polygons_attributes_of_first_point_within <- function(points,
                                                             polygons){
      if (length(points@data$row) >1) {
          points <- points[points@data$row ==1 & points@data$col ==1 ,]
      }
      po <- gIntersects(points, polygons, byid=TRUE)
      out <- foreach(polygon.number = seq_along(polygons), .combine = "rbind") %do% {
          first.point.data <- points[po[polygon.number,],]@data %>%
              slice(1)
          pd <- as(polygons[polygon.number], "SpatialPolygonsDataFrame")
          pd@data <- first.point.data
          pd
      }
  }

  Crop_image_to_regions_around_points_nameBygrid<- function(shapefile.dsn,
                                                            shapefile.layer,
                                                            image.path,
                                                            cores,
                                                            output.dir,
                                                            column.name = "unq__ID",
                                                            point.buffer.size = 4,
                                                            polygon.buffer.size = 15)  {
      image.name <- extract.name.from.path(image.path)
      points <- readOGR(shapefile.dsn,str_c(image.name,"_",shapefile.layer))
      box <- gBuffer(points, width = point.buffer.size, byid = F)
      box <- disaggregate(box)

      polygons <- as(box, "SpatialPolygons")

      polygons <- give_polygons_attributes_of_first_point_within(points,polygons)

      image <- stack(image.path)

      image.extent <- as(extent(image), "SpatialPolygons")
      proj4string(image.extent) <- proj4string(image)

      polygons.in.image <- foreach(i = seq_along(polygons),.combine = "c") %do% {
          gIntersects(polygons[i,],image.extent)
      }

      polygons <- polygons[polygons.in.image,]

      cl <- makeCluster(cores)
      registerDoParallel(cl)

      foreach (k = seq_along(polygons),
               .packages = c("raster","rgeos")) %dopar% {
                   r <- image
                   poly <- gBuffer(polygons[k,],width = polygon.buffer.size, byid = T)
                   r <- crop(r, poly)
                   tile.id <- polygons@data[k,column.name]
                   writeRaster(r, paste0(output.dir,"/",image.name,".",tile.id,".tif"),
                               overwrite = T)
               }
  }

                                          #  shapefile.dsn = grid.accuracy.region.imageCRS.dsn
                                          #  shapefile.layer = grid.accuracy.region.layer,
                                          #  output.dir = image.cropped.to.grid.accuracy.dir


  Crop_image_to_regions_around_points <- function(shapefile.dsn,
                                                  shapefile.layer,
                                                  image.path,
                                                  cores,
                                                  output.dir)  {

      points <- readOGR(shapefile.dsn, shapefile.layer)
      box <- gBuffer(points, width = 8)
      box <- disaggregate(box)

      polygons <- as(box, "SpatialPolygons")

      image <- stack(image.path)

      cl <- makeCluster(cores)
      registerDoParallel(cl)

      foreach (i = seq_along(polygons),
               .packages = c("raster")) %dopar% {
                   r <- image
                   r <- crop(r, polygons[i])
                   writeRaster(r, paste0(output.dir,"/",i,".tif"),
                               overwrite = T)
               }
  }

#+END_SRC

#+RESULTS:

** Feature Data Frame Related: texture, pca, segmentation, etc.
*** Save each band
#+begin_src R
    save_each_band <- function(image.path, band.names) {
      image <- stack(image.path)
      names(image) <- band.names
      image.name <- str_sub(basename(image.path),1,-5)
      writeRaster(image, filename = paste0(dirname(image.path),"/",image.name,"_",names(image), ".tif"), bylayer = T, format = "GTiff", overwrite = T)
  }

#+end_src

#+results:
*** Add Texture
#+begin_src R
  named.glcm <- function(image.dir, image.basename, band.appendage, window, statistics, shift, na_opt, na_val,...) {

      image.path <- paste0(image.dir, "/", image.basename,band.appendage,".tif")
      x <- raster(image.path)

      texture <- glcm(x, window = window, statistics = statistics, shift = shift, na_opt = na_opt, na_val = na_val)

      win.size <- paste0("window.",window[1])
      shift.dir <- paste0("angle.",atan(shift[1]/shift[2])*180/pi) # calc shift angle

      image.dir <- dirname(image.path)
      image.name <- str_sub(basename(image.path),1,-5)
      fn = paste0(image.dir,"/", image.basename,band.appendage, "_stat.", statistics, "_", win.size,"_",shift.dir,".tif")
      writeRaster(texture, fn, overwrite = T)
  }


  calc.texture <- function(texture.params.df,
                           image.dir,
                           image.basename) {

      texture <- mapply(named.glcm,
                        image.dir = image.dir,
                        image.basename = image.basename,
                        band.appendage = texture.params.df$band.appendage,
                        window = texture.params.df$window,
                        statistics = texture.params.df$statistics,
                        shift = texture.params.df$shift,
                        na_opt = "ignore",
                        na_val = NA)
  }

#+end_src

#+results:
*** Make new ratio bands from image
#+BEGIN_SRC R
    calc_ratios <- function(image.path, band.names, ratio.bands, scale200 = T) {
        image <- stack(image.path)
        names(image) <- band.names

        ratios <- image[[ratio.bands,drop = F]] / sum(image)

        if (scale200 == T) {
          ratios <- ratios * 200
  }

        image.name <- str_sub(basename(image.path),1,-5)
        names(ratios) <- paste0(image.name,"_ratio.",ratio.bands)
        writeRaster(ratios, filename= paste0(dirname(image.path),"/",names(ratios),".tif"),
                    bylayer = T, format= "GTiff", overwrite = T,
                    datatype = 'INT1U')
      }

      calc_ndvi <- function(image.path, band.names, ndvi_appendage = "_ndvi", scale200 = T) {

          image <- stack(image.path)
          names(image) <- band.names

          ndvi <- (image[["nir"]] - image[["red"]]) /  (image[["nir"]] + image[["red"]])

        ndvi [ndvi < 0] <- 0

          if (scale200 == T) {
              ndvi <- ndvi * 200
          }

          image.dir <- dirname(image.path)
          image.name <- str_sub(basename(image.path),1,-5)
          writeRaster(ndvi, filename=paste0(image.dir,"/",image.name,ndvi_appendage,".tif"), bylayer=TRUE,format="GTiff", overwrite = T,datatype = 'INT1U')
          return(ndvi)
      }
#+end_src

#+results:

*** Make Pixel Feature DF
#+begin_src R
      save.pixel.feature.df <- function(image.dir,
                                      image.name,
                                    feature.pattern,
                                    pixel.feature.df.append = pixel.feature.df.appendage ) {
    s <- stack(list.files(image.dir, pattern = paste0(image.name,feature.pattern), full.names = T))
    names(s) <- sub(x = names(s), pattern = "(madisonNAIP|panshpSPOT).*?_", replacement = "")
    s.df <- as.data.frame(s, xy = T)
    saveRDS(s.df, file = paste0(image.dir, "/", image.name, pixel.feature.df.append, ".rds"))
  }
#+end_src

#+results:
*** Image PCA
#+BEGIN_SRC R

  pca.transformation <- function(image.dir,
                                 image.name,
                                 feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif",
                                 pca.model.name.append = pca.model.name.appendage,
                                 out.image.appendage = pca.tile.name.append,
                                 comps.to.use = c(1,2,3),
                                 pca.dir = dd.pca.dir) {

      s <- stack(list.files(image.dir, pattern = paste0(image.name,feature.pattern), full.names = T))
      names(s) <- sub(x = names(s), pattern = ".*_", replacement = "")

      pca.model <- readRDS(str_c(pca.dir,"/",str_extract(image.name, "[a-zA-Z]+"),pca.model.name.append))

      r <- predict(s, pca.model, index = comps.to.use)

      min.r <- getRasterMin(r)
      max.r <- getRasterMax(r)
      rescaled.r <- rescale.0.255(r, min.r, max.r)

      out.path <- str_c(image.dir, "/", image.name, out.image.appendage, ".tif")
      writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U', bylayer = F)
  }


  getRasterMin <- function(t) {
      return(min(cellStats(t, stat = "min")))
  }

  getRasterMax <- function(t) {
      return(max(cellStats(t, stat = "max")))
  }

  rescale.0.255 <- function(raster,
                            min,
                            max) {
                                (raster - min)/(max-min) * 255
  }

  ## image.pca <- function(image.name,
  ##                       pca.model.name.append = pca.model.name.appendage,
  ##                       tile.dir,
  ##                       tile.name,
  ##                       in.image.appendage = ratio.tile.name.append,
  ##                       out.image.appendage = pca.tile.name.append,
  ##                       band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
  ##                       comps.to.use = c(1,2,3),
  ##                       pca.dir = dd.pca.dir) {


  ##     out.path <- str_c(tile.dir, "/", tile.name, out.image.appendage, ".tif")

  ##     s <- stack(str_c(tile.dir, "/", tile.name, in.image.appendage,".tif"))
  ##     names(s) <- band.names

  ##     pca.model <- readRDS(str_c(pca.dir,"/",image.name,pca.model.name.append))

  ##     r <- predict(s, pca.model, index = comps.to.use)

  ##     min.r <- getRasterMin(r)
  ##     max.r <- getRasterMax(r)
  ##     rescaled.r <- rescale.0.255(r, min.r, max.r)
  ##     writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')
  ## }


  make.and.save.pca.transformation <- function(image.dir,
                                               image.name,
                                               pca.model.name.append = "_pca.rds",
                                               max.sample.size = 10000,
                                               core.num = cores,
                                               feature.pattern = ".*_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi).tif",
                                               ratio.appendage = ratio.tile.name.append) {

      tile.paths <- list.files(image.dir, pattern = paste0(image.name,feature.pattern), full.names = T)

      tile.names <- str_match(tile.paths,"(.*\\.[0-9]+)_.*")[,2] %>%  unique() # get the image names of pca regions

      cl <- makeCluster(cores)
      registerDoParallel(cl)

      sr <- foreach (tile.name = tile.names, .packages = c("stringr","raster"), .combine ="rbind") %dopar% {
          t.names <- str_extract(tile.paths, paste0(".*",tile.name,".*")) %>% na.omit()
          tile <- stack(t.names)
          names(tile) <- sub(x = names(tile), pattern = ".*_", replacement = "")
          samp <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
          colnames(samp) <- names(tile)
          samp
      }

      stopImplicitCluster()
                                          # Perform PCA on sample
      pca <- prcomp(sr, scale = T)
      saveRDS(pca,paste0(image.dir,"/",image.name,pca.model.name.append))
      return(pca)
  }


  ## make.and.save.pca.transformation <- function(image.dir,
  ##                                              image.name,
  ##                                              pca.model.name.append = "_pca.rds",
  ##                                              max.sample.size = 10000,
  ##                                              core.num = cores,
  ##                                              band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
  ##                                              ratio.appendage = ratio.tile.name.append) {
  ##     tile.paths <- list.files(str_c(image.dir), pattern = paste0("*",ratio.appendage), full.names = T)

  ##     tile.names <- basename(tile.paths)

  ##     cl <- makeCluster(core.num)
  ##     registerDoParallel(cl)

  ##     sr <- foreach (i = seq_along(tile.names), .packages = c("raster"), .combine ="rbind") %dopar% {
  ##         tile <- stack(tile.paths[i])
  ##         s <- sampleRandom(tile, ifelse(ncell(tile) > max.sample.size ,max.sample.size, ncell(tile)))
  ##     }

  ##     colnames(sr) <- band.names

  ##                                         # Perform PCA on sample
  ##     pca <- prcomp(sr, scale = T)
  ##     saveRDS(pca,paste0(image.dir,"/",image.name,pca.model.name.append))

  ##     return(pca)
  ## }


  image.pca.forWholeState <- function(pca.model.name.append = pca.model.name.appendage,
                                      tile.dir,
                                      tile.name,
                                      in.image.appendage = ratio.tile.name.append,
                                      out.image.appendage = pca.tile.name.append,
                                      band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi"),
                                      comps.to.use = c(1,2,3),
                                      pca.transform) {


      out.path <- str_c(tile.dir, "/", tile.name, out.image.appendage, ".tif")

      s <- stack(str_c(tile.dir, "/", tile.name, in.image.appendage,".tif"))
      names(s) <- band.names

      r <- predict(s, pca.transform, index = comps.to.use)

      min.r <- getRasterMin(r)
      max.r <- getRasterMax(r)
      rescaled.r <- rescale.0.255(r, min.r, max.r)
      writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')
  }



  ## image.dir <- image.cropped.to.training.dir
  ## image.name <- 9
  ##                         in.image.appendage = ratio.tile.name.append
  ##                         out.image.appendage = pca.tile.name.append
  ##                         band.names = c("blue","green","red","nir","b_ratio","g_ratio","r_ratio","n_ratio","ndvi")
  ##                         max.sample.size = 10000
  ##                         comps.to.use = c(1,2,3)

  ##       out.path <- str_c(image.dir, "/", image.name, out.image.appendage, ".tif")

  ##       s <- stack(str_c(image.dir, "/", image.name, in.image.appendage,".tif"))
  ##       names(s) <- band.names

  ##       sr <- sampleRandom(s, ifelse(ncell(s) > max.sample.size, max.sample.size, ncell(s)))
  ##       pca <- prcomp(sr, scale = T)

  ##       r <- predict(s, pca, index = comps.to.use)

  ##       min.r <- getRasterMin(r)
  ##       max.r <- getRasterMax(r)
  ##       rescaled.r <- rescale.0.255(r, min.r, max.r)
  ##       writeRaster(rescaled.r, filename = out.path, overwrite=TRUE, datatype = 'INT1U')









                                          # Function takes raster stack, samples data, performs pca and returns stack of first n_pcomp bands
  ## predict_pca_wSampling_parallel <- function(stack, sampleNumber, n_pcomp, nCores = detectCores()-1) {
  ##     sr <- sampleRandom(stack,sampleNumber)
  ##     pca <- prcomp(sr, scale=T)
  ##     beginCluster()
  ##     r <- clusterR(stack, predict, args = list(pca, index = 1:n_pcomp))
  ##     endCluster()
  ##     return(r)
  ## }
#+END_SRC

#+RESULTS:
*** Segment image
This simply is a wrapper for the python script which is basically a
wrapper for slic.

#+begin_src R
  segment.multiple <- function(image.dir,
                               image.name,
                               segment.params.df) {
      segments <- mapply(segment,
                         image.dir = image.dir,
                         image.name = image.name,
                         compactness = segment.params.df$compactness,
                         segment.size = segment.params.df$segment.size)

  }

  segment  <- function(image.dir,
                       image.name,
                       compactness,
                       segment.size) {

      pixel_size <- ifelse(!is.na(str_extract(image.name,"madisonNAIP")), 1, 1.5)
      compactness <- if(!is.na(str_extract(image.name,"madisonNAIP"))) compactness else round(2/3*compactness)

      system(paste0("cd ",image.dir,";", "python ../../code/fia_segment_cmdArgs.py ",pixel_size," ",segment.size," ",compactness," ",image.name))
  }

#  segment(dd.training.dir, "madisonNAIP.3", 15, 30)

#+end_src

#+results:
*** add.features

#+begin_src R
  add.features <- function(image.dir,
                              image.name,
                              band.names,
                              ndvi = T,
                              ratio.bands,
                              texture = T,
                              texture.params.df) {

      img.path <- paste0(image.dir,"/",image.name,".tif")
      img <- stack(img.path)
      names(img) <- band.names

      save_each_band(image.path = img.path,
                     band.names = band.names)

      if (ndvi == T) {
          calc_ndvi(image.path = img.path,
                    band.names = band.names)
      }

      if (length(ratio.bands > 0)) {
          calc_ratios(image.path = img.path,
                      band.names = band.names,
                      ratio.bands = ratio.bands)
      }

      if (texture == T) {
          calc.texture(texture.params.df = texture.params.df,
                       image.dir = image.dir,
                       image.basename = image.name)
      }
  }

#+end_src

#+results:
*** segment Feature DF
#+begin_src R
    make.segment.feature.df.foreach.segmentation <- function(image.dir,
                                                             image.name,
                                                             feature.pattern,
                                                             segmentation.pattern = "_N-[0-9]+_C-[0-9]+.*") {

        segmentation.files <-  list.files(image.dir, pattern = paste0(image.name,segmentation.pattern))
        segmentation.param.appendages <- str_match(segmentation.files,paste0(image.name,"(_.*).tif"))[,2] %>% na.omit()


      out <- lapply(X = segmentation.param.appendages, FUN = function(segmentation.param.appendage) {
            make.segment.feature.df(image.dir = image.dir,
                                    image.name = image.name,
                                    segmentation.param.appendage = segmentation.param.appendage,
                                    fea.pattern = feature.pattern)
        })

    }


    make.segment.feature.df <- function(image.dir,
                                        image.name,
                                        segmentation.param.appendage,
                                        fea.pattern,
                                        segment.feature.appendage = "_SegmentFeatureDF.rds") {

        fea <- stack(list.files(image.dir, pattern = paste0(image.name,fea.pattern), full.names = T))
        names(fea) <- sub(x = names(fea), pattern = "(madisonNAIP|panshpSPOT).*?_", replacement = "")

        seg.path <- paste0(image.dir,"/",image.name,segmentation.param.appendage, ".tif")
        seg <- raster(seg.path)

                                            # Create a data_frame where mean and variances are calculated by zone
        x <- as.data.frame(fea, xy = T)
        s <- as.data.frame(seg)
        colnames(s) <- "segment"
        r <- bind_cols(x,s)
        r2 <- r %>%
            group_by(segment)

        mean.and.sd <- r2 %>%
            summarize_each(funs(mean(.,na.rm = T), sd(., na.rm = T))) %>%
            select(-x_mean, -y_mean)

        image.name.df = data.frame(image.name = rep(image.name, nrow(mean.and.sd)))

        out <- bind_cols(mean.and.sd, image.name.df)


        names <- colnames(out)
        names <- str_replace(names, "\\(",".")
        names <- str_replace(names, "\\)",".")
        names <- str_replace(names, "\\:",".")
        colnames(out) <- names
        saveRDS(out, file = paste0(image.dir,"/",image.name,segmentation.param.appendage,segment.feature.appendage))
        out
    }



  #  make.segment.feature.df(dd.training.dir, "madisonNAIP.1", segmentation.param.appendage = "_N-100_C-10", feature.pattern = feature.pattern)

#+end_src

#+results:

*** make.feature.df
#+begin_src R
  make.feature.df <- function(image.dir,
                              image.name,
                              band.names,
                              ndvi = T,
                              ratio.bands,
                              texture = T,
                              texture.params.df,
                              feature.pattern = "_(blue|green|red|nir|ratio.blue|ratio.green|ratio.red|ratio.nir|ndvi|ratio.nir_stat\\.\\w+_window\\.\\d+_angle\\..?\\d+).tif",
                              pixel.df,
                                          #                              pca.features = c("blue","green","red","nir","ndvi","ratio.blue","ratio.green","ratio.red","ratio.nir"),
                              pca.features = c("blue","green","red","nir"),
                              segmentation = T,
                              segment.params.df,
                              segment.feature.df = T) {

      add.features(image.dir,
                   image.name,
                   band.names,
                   ndvi = T,
                   ratio.bands,
                   texture = T,
                   texture.params.df)

      if (pixel.df ==T) {

          save.pixel.feature.df(image.dir = image.dir,
                                image.name = image.name,
                                feature.pattern)}

      pca.transformation(image.dir = image.dir,
                         image.name = image.name)

      if (segmentation == T) {

          segment.multiple(image.dir = image.dir,
                           image.name = image.name,
                           segment.params.df = segment.params.df)}

      if (segment.feature.df == T) {

          make.segment.feature.df.foreach.segmentation(image.dir = image.dir,
                                                       image.name = image.name,
                                                       feature.pattern = feature.pattern)}


  }
#+end_src

#+results:

** polygonize segment raster with gdal and add Class to shapefile

#+BEGIN_SRC R
  gdal_polygonizeR <- function(x, outshape=NULL, gdalformat = 'ESRI Shapefile',
                               pypath=NULL, readpoly=TRUE, quiet=TRUE) {
      if (isTRUE(readpoly)) require(rgdal)
      if (is.null(pypath)) {
          pypath <- Sys.which('gdal_polygonize.py')
      }
      if (!file.exists(pypath)) stop("Can't find gdal_polygonize.py on your system.")
      owd <- getwd()
      on.exit(setwd(owd))
      setwd(dirname(pypath))
      if (!is.null(outshape)) {
          outshape <- sub('\\.shp$', '', outshape)
          f.exists <- file.exists(paste(outshape, c('shp', 'shx', 'dbf'), sep='.'))
          if (any(f.exists))
              stop(sprintf('File already exists: %s',
                           toString(paste(outshape, c('shp', 'shx', 'dbf'),
                                          sep='.')[f.exists])), call.=FALSE)
      } else outshape <- tempfile()
      if (is(x, 'Raster')) {
          require(raster)
          writeRaster(x, {f <- tempfile(fileext='.asc')})
          rastpath <- normalizePath(f)
      } else if (is.character(x)) {
          rastpath <- normalizePath(x)
      } else stop('x must be a file path (character string), or a Raster object.')
      system2('python', args=(sprintf('"%1$s" "%2$s" -f "%3$s" "%4$s.shp"',
                                      pypath, rastpath, gdalformat, outshape)))
      if (isTRUE(readpoly)) {
          shp <- readOGR(dirname(outshape), layer = basename(outshape), verbose=!quiet)
          return(shp)
      }
      return(NULL)
  }


  polygonize.and.add.Class <- function(image.dir,
                                       image.name,
                                       segment.appendage = segment.tile.name.append,
                                       no.class = "N") {
      seg <- raster(paste0(image.dir,"/",image.name,segment.appendage,'.tif'))
      segPoly <- gdal_polygonizeR(seg)
      segPoly$Class <- no.class
      writeOGR(obj = segPoly,
               dsn = paste0(image.dir,"/",image.name),
               layer = paste0(image.name,segment.appendage),
               driver = "ESRI Shapefile",
               overwrite = T)
  }






#+END_SRC

#+RESULTS:

** make.model.building.df
take output of "make.feature.df" and make
model building df (feature dataframes with class assignment).

#+begin_src R

  make.model.building.df <- function(){

}

#+end_src

#+results:

** Create ModelBuilding dataframe
#+BEGIN_SRC R
  getSegment.class.and.features.Within.Polygon<-function(SegmentFeatureDF,
                                                         training.sp,
                                                         seg.tiles.dir,
                                                         seg.params){
      seg.files <- list.files(seg.tiles.dir, pattern = str_c(seg.params,".tif$"), full.names = T)
                                          # find number of pixels in each segment
      n.pixels.per.seg <- foreach(seg.file = seg.files, .combine = "rbind") %do% {
          seg <- stack(seg.file)
          s.df <- as.data.frame(seg) %>%
              gather(key = tile.name, value = segment.id) %>%
              group_by(segment.id, tile.name) %>%
              summarize(n.pixels.per.seg = n())
      }
                                          # find number of pixels in each segment are in a polygon
      n.pixels.per.seg.in.polygon <- foreach(seg.file = seg.files, .combine = "rbind") %do% {

          seg <- stack(seg.file)
          ei <- as(extent(seg), "SpatialPolygons")

          if(gIntersects(ei, as(training.sp,"SpatialPolygons"))) {

              a <- raster::extract(seg, as(training.sp,"SpatialPolygons"), df = T)

              a <- a %>%
                  gather(key = tile.name, value = segment.id, -ID) %>%
                  rename(polygon.id = ID) %>%
                  group_by(polygon.id, tile.name, segment.id) %>%
                  summarize(n.pixels.per.seg.in.polygon = n())
          }
      }
                                          # get pct of segment in a polygon,
                                          # filter segments that have more than 50%,
                                          #join Class information from polygons
      if(!is.null(n.pixels.per.seg.in.polygon)) {

          n.pixels <- left_join(n.pixels.per.seg.in.polygon,n.pixels.per.seg) %>%
              mutate(pct.seg.in.polygon = n.pixels.per.seg.in.polygon/n.pixels.per.seg) %>%
              filter(pct.seg.in.polygon >= .5) %>%
              left_join(.,training.sp@data, by = c("polygon.id" = "id")) %>%
              ungroup() %>%
              mutate(tile.name = str_replace(tile.name, "\\.", "-"),
                     tile.name =  str_extract(tile.name, ".*-[0-9]+_"),
                     tile.name = str_sub(tile.name,1,-2)) %>%
              mutate(segment = segment.id)

          left_join(n.pixels, SegmentFeatureDF) %>%
              dplyr::select(-segment,
                            -segment.id,
                            -tile.name,
                            -image.name,
                            -polygon.id,
                            -n.pixels.per.seg,
                            -n.pixels.per.seg.in.polygon,
                            -pct.seg.in.polygon)        %>%
              filter(complete.cases(.))
      }
  }

                                          # returns dataframe of values of pixels within polygon
  getPixel.Class.and.Coords.Within.Polygon <- function(PixelFeatureDF,
                                                       training.sp) {
      xy <- select(PixelFeatureDF,x,y) %>% data.frame
      PixelFeatureDF <- data.frame(PixelFeatureDF)
      coordinates(PixelFeatureDF) <- xy
      proj4string(PixelFeatureDF) <- utm16

      training.sp <- spTransform(training.sp,utm16)

      pts.in.poly <- over(PixelFeatureDF,training.sp)
      PixelFeatureDF@data <- cbind(PixelFeatureDF@data, pts.in.poly)
      PixelFeatureDF <- PixelFeatureDF[which(complete.cases(pts.in.poly)),]
      PixelFeatureDF@data
  }

#+END_SRC
#+RESULTS:

** Build and Save Models
#+BEGIN_SRC R
  Build.and.Save.models <- function(dir = dd.training.dir,
                                    modelBuildingData = ModelBuildingRDS,
                                    models.dir = Models.dir,
                                    image.name){

      dat <- readRDS(paste0(dir,"/",modelBuildingData)) %>%
          as.data.frame() %>%
          filter(complete.cases(.))

      image.and.segmentation.stem = str_replace(modelBuildingData, ModelBuilding.appendage,"")

      names <- colnames(dat)
      names <- str_replace(names, "\\(",".")
      names <- str_replace(names, "\\)",".")
      names <- str_replace(names, "\\:",".")
      colnames(dat) <- names

                                          # Create Tasks
      tsk <- makeClassifTask(id = paste0(image.name,"_all"), data = dat, target = "Class")

                                          # Make Learners
      RF_prob <- makeLearner(id = "rf_prob","classif.randomForest", predict.type = "prob", fix.factors.prediction = TRUE)
#      RF_response <- makeLearner(id = "rf_resp", "classif.randomForest", predict.type = "response", fix.factors.prediction = TRUE)
      SVM_response <- makeLearner(id = "svm_resp", "classif.svm", predict.type = "response", fix.factors.prediction = TRUE)

#      learner.list <- list(RF_prob = RF_prob, RF_response = RF_response, SVM_response = SVM_response)
      learner.list <- list(RF_prob = RF_prob, SVM_response = SVM_response)

                                          # Train Learners on Tasks, Make models
                                          #         cl<-makeCluster(cores)
                                          #         registerDoParallel(cl)

      models <- foreach(lnr = learner.list) %do% {
              mod <- train(lnr, tsk)
              mod
          }

      saveRDS(models, file = paste0(models.dir,"/",image.and.segmentation.stem, models.appendage))
  }

#+END_SRC

#+results:

** Classify Raster
#+BEGIN_SRC R

  classify.segmented.raster <- function(segment.feature.df.dir,
                                        segment.dir,
                                        model.dir,
                                        model.name.rds = "models",
                                        segment.feature.appendage = segment.feature.df.name.append,
                                        segmentation.appendage = segment.tile.name.append,
                                        segmentation.prms,
                                        classify.out.dir,
                                        tile.name = i) {
      df <- readRDS(paste0(segment.feature.df.dir,"/",tile.name,segment.feature.appendage))
      models <-readRDS(paste0(model.dir,"/",model.name.rds))
  #    umod <- unlist(models, recursive = F)
      seg.path <- paste0(segment.dir,"/",tile.name,segment.tile.name.append)
      seg <- raster(seg.path)
                                          #       dfRowsWithNA <- which(is.na(df[,2]))
      complete.df <- df[complete.cases(df),] # svm can't predict with NAs
      lapply(models, function(mod) {
          pred <- predict(mod, newdata = complete.df)
          response <- factor(as.character(pred$data$response), levels = c("g","i","t","o"))
          m <- cbind(zone = complete.df$segment, response)
          m <- left_join(as.data.frame(df["segment"]), as.data.frame(m), by = c("segment" = "zone"))
          r <- reclassify(seg, m)
                                          #        x <- data.frame(ID = 1:4, LandCover = c("G","I","T","O")) %>%
                                          #            filter(LandCover %in% levels(factor(response)))
                                          #        levels(r) <- x
          if (ncol(pred$data) > 2) {
              prob <- (pred$data[,grep("prob.*", x = colnames(pred$data))]) # get columns that contain probabilities
              ProbOfClass <- apply(prob, MARGIN = 1, FUN = max)
              m <- cbind(segment = df$segment, ProbOfClass)
              m <- left_join(as.data.frame(df["segment"]), as.data.frame(m))
              p <- reclassify(seg, m)
              r <- stack(r,p)
          }
          path <- paste0(segment.dir,"/",ClassifiedTilesDirName,"/",tile.name,"_",segmentation.prms,"_",mod$task.desc$id,"_",mod$learner$id,".tif")
          writeRaster(r, path, overwrite=TRUE)
          print(path)
      })
  }


  classify.pixel.raster <- function(tile.dir = dd.accuracy.dir,
                                    tile.name,
                                    pixelFeatureDF.appendage = pixel.feature.df.appendage,
                                    model.dir = Models.dir,
                                    model.rds,
                                    seg.prms = "Pixel") {
      ras <- stack(str_c(tile.dir,"/",tile.name,".tif"))
      pix.mods <- readRDS(str_c(model.dir,"/",model.rds))
#      pix.umods <- unlist(pix.mods, recursive = F)

      pix.feature.df <- readRDS(str_c(tile.dir,"/",tile.name,pixelFeatureDF.appendage,".rds"))

      if(!is.null(pix.feature.df$y)) {
          pix.feature.df <- dplyr::select(pix.feature.df, -x, -y)
      }

                                          # I set NA's to 0 here.  Not the best choice.  Not sure why they exist.
                                          # imputing to mean would probably be better

      pix.feature.df <- as.matrix(pix.feature.df)

      pix.feature.df[which(is.na(pix.feature.df))] <- 0

      pix.feature.df <- as.data.frame(pix.feature.df)


      lapply(pix.mods, function(pix.mod) {
          pred <- predict(pix.mod, newdata = pix.feature.df)
          a <- ras[[1]]
          values(a) <- pred$data$response
          path <- paste0(tile.dir,"/",ClassifiedTilesDirName,"/",tile.name,"_",seg.prms,"_",pix.mod$task.desc$id,"_",pix.mod$learner$id,".tif")
          writeRaster(a, path, overwrite = T)
          print(path)
      })
  }








#+END_SRC

#+RESULTS:

#+BEGIN_SRC R :results graphics :file figs/pixClss.png
                                          #plot(a)
#+END_SRC

#+RESULTS:
[[file:figs/pixClss.png]]

** Calculate Percent Cover in Classified Tiles
#+BEGIN_SRC R

  get.prcnt.class <- function(points,r) {
      r <- crop(r,points)  # should I do a mask instead??
      g <- cellStats(r == 1, stat = sum)
      im <- cellStats(r == 2, stat = sum)
      tr <- cellStats(r == 3, stat = sum)
      o <-  cellStats(r == 4, stat = sum)
      totC <- ncell(r)
      return(c(pct_g_pred = g/totC, pct_i_pred = im/totC, pct_t_pred = tr/totC, pct_o_pred = o/totC))
  }


  get_area_convexHull <- function(points) {
      ch <- chull(coordinates(points))
      coords <- coordinates(points)[c(ch,ch[1]),]
      poly <- SpatialPolygons(list(Polygons(list(Polygon(coords)),ID = 1)))
      gArea(poly)
  }



  calculate.percent.cover.in.classified.tile <- function(pts,
                                                         tile.dir = dd.accuracy.classified.dir,
                                                         tile.pth,
                                                         n.rows.and.columns.subset,
                                                         mod = 1,
                                                         mad.grid.id.pattern = "mad-[0-9]+m-[0-9]+",
                                                         grid.pattern = "[a-zA-Z]{3}-[0-9]+m-[0-9]+_",
                                                         image.pattern = "[a-zA-Z]{5}[a-zA-Z]+",
                                                         target.pattern = "all|grass|impervious|tree",
                                                         model.pattern = "rf_prob|rf_resp|svm_resp",
                                                         seg.prms = "N-[0-9]+_C-[0-9]+|Pixel"
                                                         ) {
      tile.nm <- basename(tile.pth)


      pts.sub <- pts@data  %>%
          filter.by.row.and.col(.,n.rows.and.columns.subset, mod = mod)

      coordinates(pts.sub) <- ~ crds_x1 + crds_x2

      proj4string(pts.sub) <- utm16
      tile.unique.name <- str_extract(tile.pth, mad.grid.id.pattern)
      pts.at.grid <- pts.sub[which(pts.sub@data$unq__ID == tile.unique.name),]
      tile <- raster(tile.pth, proj4string = "+init:epsg=32616")

      area.pts <- get_area_convexHull(pts.at.grid)

      if(!is.null(raster::intersect(extent(tile),bbox(pts.at.grid)))) {

          get.prcnt.class(pts.at.grid,tile) %>%
              t() %>%
              as.data.frame() %>%
              mutate(grid.tile.target.model = tile.nm,
                     grid = str_sub(str_extract(grid.tile.target.model, grid.pattern),1,-2),
                     image =  str_extract(grid.tile.target.model, image.pattern),
                     target.cover = str_extract(grid.tile.target.model, target.pattern),
                     model =  str_extract(grid.tile.target.model, model.pattern),
                     n.points = n.rows.and.columns.subset * n.rows.and.columns.subset,
                     area = area.pts,
                     seg.params = str_extract(grid.tile.target.model, seg.prms),
                     target.type = ifelse(target.cover == "all", "multinomial", "binomial"))
      }
  }

#+END_SRC

#+RESULTS:

** Calculate Percent Cover of Grids, subsetted
#+BEGIN_SRC R
  filter.by.row.and.col <- function(df,nrow.and.col, mod) {
      nrow <-df %>%
          group_by(unq__ID) %>%
          summarize(nrow = max(row))

      df <- left_join(df,nrow)

      df %>%
          filter(nrow >= nrow.and.col,   # remove grids that have fewer than the number of rows & columns
                 row <= nrow.and.col,    # remove rows greater than the number we are interested in
                 col <=nrow.and.col,   # same for columns as rows
                 row %% mod == 0,
                 col %% mod == 0)
  }

  add.n.pts.per.grid <- function(df){
      n.pts<-df %>%
          group_by(unq__ID) %>%
          summarize(n.points = n())

      left_join(df,n.pts)
  }


  get.pct.cvr.typ <- function(df) {
      df %>%
          group_by(unq__ID, cvr_typ,n.points, area) %>%
          summarize(number = n()) %>%
          ungroup() %>%
          mutate(google.truth.pct.cover = number/n.points) %>%
          dplyr::select(-number)
  }

  combine.classes.to.g.i.t.o <- function(df) {

      df %>%
          mutate(cvr_typ = as.character(cvr_typ),
                 cvr_typ = ifelse(cvr_typ == "s",
                                  "i",
                                  cvr_typ),
                 cvr_typ = ifelse(cvr_typ != "g" &
                                  cvr_typ != "i" &
                                  cvr_typ != "t", "o", cvr_typ)) %>%
          group_by(unq__ID, cvr_typ, n.points, area) %>%
          summarize(google.truth.pct.cover = sum(google.truth.pct.cover))

  }


  calc.binomial.pct.cvrs <- function(df) {

      out <- foreach(target.cvr.type = c("g","i","t")) %do%{
          df %>%
              mutate(cvr_typ = ifelse(cvr_typ == target.cvr.type, cvr_typ, "o")) %>%
              group_by(unq__ID, n.points, cvr_typ) %>%
              summarize(pct.cover = sum(pct.cover)) %>%
              mutate(target.type = "binomial",
                     target.cover = target.cvr.type,
                     target.cover = ifelse(target.cover == "g", "grass",
                                    ifelse(target.cover == "t", "tree",
                                           "impervious"))) %>%
              spread(key = cvr_typ, value = pct.cover)
      }
      out <- bind_rows(out)
      out %>%
          rename(pct.g.googleEarth = g, pct.i.googleEarth = i, pct.t.googleEarth = t, pct.o.googleEarth = o)
  }



  get.area.convexHull <- function(x_coord, y_coord) {
      m <- matrix(c(x_coord, y_coord), ncol = 2)
      ch <- chull(m)
      coords <- m[c(ch,ch[1]),]
      poly <- SpatialPolygons(list(Polygons(list(Polygon(coords)),ID = 1)))
      gArea(poly)
  }



  calc.pct.cvr.for.grid.subset <- function(df,
                                           n.rows.and.columns.for.subset=20,
                                           mod,
                                           gridID = "unq__ID") {


      df <- filter.by.row.and.col(df, n.rows.and.columns.for.subset, mod) %>%
          add.n.pts.per.grid() %>%
          group_by_(gridID)


      area.df <- df %>%
          summarize(area = get.area.convexHull(crds_x1, crds_x2))

      df <- left_join(df, area.df)


      df <- df %>%
          get.pct.cvr.typ() %>%
          combine.classes.to.g.i.t.o() %>%
                                          #               ungroup() %>%
                                          #               dplyr::select(-n.points) %>%
          spread(., key = cvr_typ, value = google.truth.pct.cover, fill = 0)

                                          #         df[is.na(df)] <- 0

      df.multnm <- df %>%
          mutate(target.type = "multinomial") %>%
          rename(pct.g.googleEarth = g, pct.i.googleEarth = i, pct.t.googleEarth = t) %>%
          mutate(target.cover = "all")

      if(!is.null(df.multnm$o)) { df.multnm <- rename(df.multnm, pct.o.googleEarth = o)}

      df <- df %>%
          gather(key = cvr_typ, value = pct.cover, -unq__ID, -n.points)

      df.binm <- df %>%
          calc.binomial.pct.cvrs()


      df.out <- bind_rows(df.binm, df.multnm)
      return(df.out)
  }



#+END_SRC

#+RESULTS:

** Point-wise error functions
#+BEGIN_SRC R

      calcErrorAllMultinomial <-  function(pts, tile, Pixel = F) {
          classification <- raster::extract(classified.tile, pts)
          if(Pixel == T) {
              lvls <- levels(classified.tile)[[1]]
              classification <- mapvalues(classification, from = lvls[,1], to = as.character(lvls[,2]))
          } else {
              classification <- mapvalues(classification, from = c(1,2,3,4), to = c("g","i","t","o"))
          }
          google = pts@data$cvr_typ
          overall.error <- 1 - mean(classification == google)
          pct.grass.classified.as.other <- 1 - mean(classification[which(google == "g")] == google[which(google == "g")])
          pct.impervious.classified.as.other <- 1 - mean(classification[which(google == "i")] == google[which(google == "i")])
          pct.tree.classified.as.other <- 1 - mean(classification[which(google == "t")] == google[which(google == "t")])
          error <- c(overall.error = overall.error,
                     pct.grass.classified.as.other = pct.grass.classified.as.other,
                     pct.impervious.classified.as.other = pct.impervious.classified.as.other,
                     pct.tree.classified.as.other = pct.tree.classified.as.other)
          return(error)
      }

      calcErrorBinomial <-  function(pts, tile, target, Pixel = F) {
          classification <- raster::extract(classified.tile, pts)
          if(Pixel == T) {
              lvls <- levels(classified.tile)[[1]]
              classification <- mapvalues(classification, from = lvls[,1], to = as.character(lvls[,2]))
          } else {
              classification <- mapvalues(classification, from = c(1,2,3,4), to = c("g","i","t","o"))
          }
          classification <- ifelse(classification == target, classification, "o")
          google <- pts@data$cvr_typ
          google <- ifelse(google == target, google, "o")
          overall.error <- 1 - mean(classification == google)
          pct.grass.classified.as.other <- 1 - mean(classification[which(google == "g")] == google[which(google == "g")])
          pct.impervious.classified.as.other <- 1 - mean(classification[which(google == "i")] == google[which(google == "i")])
          pct.tree.classified.as.other <- 1 - mean(classification[which(google == "t")] == google[which(google == "t")])
          error <- c(overall.error = overall.error,
                     pct.grass.classified.as.other = pct.grass.classified.as.other,
                     pct.impervious.classified.as.other = pct.impervious.classified.as.other,
                     pct.tree.classified.as.other = pct.tree.classified.as.other)
          return(error)
      }




      calcConfusionMat <- function(pts, tile) {
          classification <- raster::extract(classified.tile, pts)
          classification <- mapvalues(classification, from = c(1,2,3,4), to = c("g","i","t","o"))
          table(classification, google = pts@data$cvr_typ)
      }
#+END_SRC
#+RESULTS:

** NEXT Plot points on classifed tile ADD OVERALL ACCURACY IN TITLE
#+BEGIN_SRC R

  pts.on.classified.tile.plot.ErrorinTitle <- function(error, grd.pts, classified.tile.path, fig.dir, target = NULL) {

        grid.name <- str_match(classified.tile.path, ".*([a-z]{3}\\.[0-9]+m\\.[0-9]+)_.*")[,2]
        pts <- grd.pts[grd.pts@data$unq__ID == grid.name,]
    pts@data <- pts@data %>%
          mutate(x = coordinates(pts)[,1],
                 y = coordinates(pts)[,2])

      if(target == "a") {
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, color = cvr_typ))
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, fill = cvr_typ), shape = 21, color = "black", size =2, stroke = .2)
      } else {
          pts@data <- pts@data %>%
              mutate(cvr_typ = ifelse(cvr_typ == target, cvr_typ, "o"))
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, color = cvr_typ))
      }
      r.df <- as.data.frame(raster(classified.tile.path), xy = T)
      names(r.df) <- c("x","y","cvr_typ")
                                          #        r.df <- r.df %>%
                                          #            mutate(cvr_typ = mapvalues(cvr_typ, from = c(1,2,3,4), to = c("g","i","t","o")))
      pxls.plot <- ggplot() + geom_raster(data = r.df, aes(x = x, y = y, fill = cvr_typ))
      title <- ggtitle(label = paste0("err:",round(error,2),"_",names(raster(classified.tile.path))))
      UTC_pal <- c(g = "#ffff99", i = "#f0027f", t = "#7fc97f", o = "#666666")
      plt <- pxls.plot + pts.plot + title + scale_fill_manual(values = UTC_pal)+ scale_color_manual(values = UTC_pal) + coord_equal()

      dir.create(fig.dir)

      png(filename = paste0(fig.dir,"/","Err.",round(error,2),"_",names(raster(classified.tile.path)),".png"))
      print(plt)
      dev.off()
  #    plt
  }

  pts.on.classified.tile.plot <- function(pts, classified.tile, fig.dir, target = NULL) {

      if(target == "a") {
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, color = cvr_typ))
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, fill = cvr_typ), shape = 21, color = "black", size =2, stroke = .2)
      } else {
          pts@data <- pts@data %>%
              mutate(cvr_typ = ifelse(cvr_typ == target, cvr_typ, "o"))
          pts.plot <- geom_point(data = pts@data, aes(x = x, y = y, color = cvr_typ))
      }
      r.df <- as.data.frame(classified.tile, xy = T)
      names(r.df) <- c("x","y","cvr_typ")
                                          #        r.df <- r.df %>%
                                          #            mutate(cvr_typ = mapvalues(cvr_typ, from = c(1,2,3,4), to = c("g","i","t","o")))
      pxls.plot <- ggplot() + geom_raster(data = r.df, aes(x = x, y = y, fill = cvr_typ))
      title <- ggtitle(label = names(classified.tile))
      UTC_pal <- c(g = "#ffff99", i = "#f0027f", t = "#7fc97f", o = "#666666")
      plt <- pxls.plot + pts.plot + title + scale_fill_manual(values = UTC_pal)+ scale_color_manual(values = UTC_pal) + coord_equal()

      dir.create(fig.dir)

      png(filename = paste0(fig.dir,"/",names(classified.tile),".png"))
      print(plt)
      dev.off()
      plt
  }
#+END_SRC
#+RESULTS:

** other Functions
#+BEGIN_SRC R

  image_to_classified_image <- function()





                                          # contained urban, don't intersect water = as is
                                          # contained urban, intersect water = mask water
                                          # intersect urban, don't intersect water = mask urban
                                          # intersect urban, intersect water = mask urban & water
                                          # if none of the above, don't write the raster



      Mask_water_crops_urban <- function(image.full.path, water, crops, urban) {

      }




  Water_Urban_mask <- function(tile.path, tile.name, urban, water) {
                                          # load image tile
      tile <- stack(tile.path)
                                          # get extent image and make sp object
      et <- as(extent(tile), "SpatialPolygons")
      proj4string(et) <- "+init=epsg:26916"
                                          # Mask out non-urban areas
      if(gContainsProperly(urban,et) & !gIntersects(water,et)){
          writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
      } else if (gContainsProperly(urban,et) & gIntersects(water,et)) {
          tile <- mask(tile, water, inverse = T)
          writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
      } else if (gIntersects(urban, et) & !gIntersects(water,et)) {
          tile <- mask(tile, urban)
          writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
      } else if (gIntersects(urban, et) & gIntersects(water,et)) {
          tile <- mask(tile, urban)
          tile <- mask(tile, water, inverse = T)
          writeRaster(tile, filename = str_c(masked.tiles.directory,"/",tile.name), overwrite = T)
      }
  }

  Crop_mask <- function(tile.path, tile.name, CDL_stack, n_years){

      tile <- stack(tile.path)
      crops <- crop(CDL_stack, tile)

                                          # These are the values in the CDL that correspond to non crop cover types and not water
      NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
                                          # open water is 111

      NonCroppedValues <- c(0,63:65, 81:83, 87:88, 112, 121:124, 131, 141:143, 152, 176, 190, 195)
                                          # open water is 111. I don't include it in the above list so that it gets masked

                                          # I'm going to add 37, Other Hay/Non-alfalfa, to the non crop cover types
      NonCroppedValues <- c(NonCroppedValues, 37)
                                          # I'm going to add 36, Alfalfa, to the non crop cover types
      NonCroppedValues <- c(NonCroppedValues, 36)

                                          # find cells that have been assigned crop all three years
      crops[crops %in% NonCroppedValues] <- 0
      crops[!(crops %in% NonCroppedValues)] <- 1
      cropsum <- overlay(crops, fun = sum)

      dis.cropsum <- disaggregate(cropsum, fact = 20)
      dis.cropsum <- resample(dis.cropsum, tile, "ngb")
      masked_tile <- mask(tile, dis.cropsum, maskvalue = n_years)

                                          #               Save Image
      writeRaster(masked_tile, paste0(crop.masked.tiles.directory, "/", tile.name), overwrite = T)
  }








#+END_SRC

#+RESULTS:


